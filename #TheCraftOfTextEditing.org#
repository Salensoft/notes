* Introduction
** Get_Line
   + inputs
     + a prompt string
     + a buffer to accept the input, at least 2 character long
     + an indication of the buffer length
   + outputs
     + a success/fail status
     + success : the input is stored in the supplied buffer, the end of the
       input is marked with NUL character
     + fail : the buffer may have been modified but won't contain valid input
#+BEGIN_SRC c
  FLAG Get_Line (char *prompt, char *buffer, int len, char *default) {
    char *cptr = buffer;
    Flag isinsert = TRUE;
    FLAG waskey = TRUE;
    int key;

    if (len < 2) //safety check
      return FALSE;

    strcpy(buffer, default);
    for (;;) {
      ToStartOfLine();
      ClearLine();
      printf("%s: %s", prompt, buffer);
      PositionCursor(strlen(prompt) + 2 + (cptr - buffer));

      key = KeyGet();
      if (isprint(key)) {
        if (!waskey){
          cptr = buffer;
          ,*cptr = NUL;
          waskey = TRUE;
        }
        if (isinsert) {
          if (buffer + strlen(buffer) >= len - 1) Beep();
          else {
            memmove(cptr + 1, cptr, strlen(cptr) + 1);
            ,*cptr++ = key;
            ,*cptr = NUL;
          }
        }
        else {
          if (*cptr == NUL) {
            //end of input, so append to buffer
            if (buffer + strlen(buffer) >= len - 1)
              Beep();
            else {
              ,*cptr++ = key;
              ,*cptr = NUL;
            }
          }
          else
            ,*cptr++ = key;//replace
        }
      }
      else {
        switch (key) {
        case KEYBACK:
          if (!waskey) {
            cptr = buffer;
            ,*cptr = BUL;
            waskey = TRUE;
          }
          if (cptr > buffer) {
            xstrcpy(cptr - 1, cptr);
            cptr--;
            ,*cptr = NUL;
          }
          break;
        case KEYDEL: //delete the following char
          if (cptr < buffer + strlen(buffer))
            xstrcpy(cptr, cptr + 1);
          else Beep();
          break;
        case KEYENTER:
          printf("\n");
          return (TRUE);
        case KEYLEFT:
          if (cptr > buffer) cptr--;
          waskey = TRUE;
          break;
        case KEYRIGHT:
          if (cptr < buffer + strlen(buffer)) cptr++;
          waskey = TRUE;
          break;
        case KEYSTART: //move to start of response
          cptr = buffer;
          waskey = TRUE;
          break;
        case KEYEND: //move to end of response
          cptr = buffer + strlen(buffer);
          waskey = TRUE;
          break;
        case KEYQUOTE: //insert the next character, even if it's a control char
          if (!waskey) {
            cptr = buffer;
            ,*cptr = NUL;
            waskey = TRUE;
          }
          key = KeyGet();
          if (isinsert) {
            if (buffer + strlen(buffer) >= len -  1)
              Beep();
            else { //move rest of line and insert
              memmove(cptr + 1, cptr, strlen(cptr) + 1);
              ,*cptr++ = key;
              ,*cptr = NUL;
            }
          }
          else {
            if (*cptr == NUL) { //end of input, so append
              if (buffer + strlen(buffer) >= len - 1)
                Beep();
              else {
                ,*cptr++ = key;
                ,*cptr = NUL;
              }
            }
            else
              ,*cptr++ = key; //replace
          }
          break;
        case KEYCLEAR: //erase response
          cptr = buffer;
          ,*cptr = NUL;
          waskey = TRUE;
          break;
        case KEYDEFAULT: //restore default response
          strcpy(buffer, default);
          cptr = buffer;
          waskey = FALSE;
          break;
        case KEYCANCEL: //abort out of editing
          return (FALSE);
        case KEYREDISPLAY: //redisplay the prompt and resp
          break;
        case KEYINSERT: //set insert mode
          isinsert = TRUE;
          break;
        case KEYREPLACE: //set replace mode
          isinsert = FALSE;
        default:
          Beep();
          break;
        }
      }
    }
  }
#+END_SRC
** Forest
   + What characteristics of the display and keyboard affect text editing
   + How should the program cope with presenting output on different way
   + What view of the text should be presented to the user
   + How should the text be managed so that large amounts of text could be
     edited efficiently
   + How should display updating occur so that editing changes are efficiently
     presented to the user
   + How should the command set be designed? What should the meanings of the
     various commands be?
   + How should the program be designed so that the user can change how it operates
* Chap1: Users
* Chap3 Implementation Language
** General consideration
*** Text handle power
    + waiting for user input
    + parsing that input
    + setting up to execute the commands
    + executing the commands
    + determining the effect of those commands on the screen
    + update the screen
*** support for extensibility
    + late binding of names to procedures through indirect calls, dynamic linking,
      or other techniques
    + retaining and using the symbol table information at run time so that the user
      can think of changes in terms of names, not address
    + internal error and consistency checking under program control so that users
      can be protected from their mistakes
    + the ability to add code to the executing editor
*** Large project support
    + division of the program into separate modules
    + division of the program into separate files
    + separate compilation
    + a way to organize the global name space
    + a way to keep objects out of the global name space
    + automatic verification of procedure call/declaration compatibility
    + conditional compilation
    + compilation constraint
    + a way of constructing "data abstraction" that package procedures and private state
      information
    + a way of dynamically allocating memory
* chap4 Editing models
** one-dimensional array
** two-dimensional array
** list of lines
** paged models
** objects
** dealing with real text
   + text ::
     + characters
     + words
     + phrases
     + sentences
     + paragraphs
     + subsections
     + sections
     + chapters
     + documents
* chap5 file formats
* chap6 the internal sub-editor
** Basic concepts and definition
   + Buffer ::
     + one file to many buffer
   + write, read, insert
   + point, the point can exist only between two characters: it's
     never on a character.
   + The start of the buffer(which corresponds to the first location in the
     file) is considered *before* or *backward from* the point. The end of the buffer
     is considered to be *after* or *forward from* the point.
   + mark :: an object that can remember a position. There can be any number of
             marks, and more than one mark can remember the same position. A
             mark is always located between two character
     + e.g. a mark may remember a specific locaion for future reference.
       For example, a command might paginate a file. In this case, a mark would
       remember where the point was when the command was invoked. THus the point
       could be moved during the re-pagination and returned to its intial starting
       place.
     + A mark can serve as bound for iteration. For example, the "fill paragraph"
       command might place a mark at its starting place, move to the end of the
       paragraph and place a mark there, then move to the begining of the paragraph,
       then move to the beginning of the paragraph. It then performs a "fill region"
       operation, filling from the point to the location of the second mark.
     + normal marks :: move with insertion
     + fixed marks :: remain in place
   + When there is exactly one mark, the range of characters between the point
     and the mark is called the *region*
   + mode :: a set of alternations to the user-oriented command set.
   + character :: basic unit of change within a buffer
** internal data structures
   + world ::
#+BEGIN_SRC c
  struct world {
    struct buffer *buffer_chain;
    struct buffer *current_buffer;
  };
#+END_SRC
   + buffer ::
#+BEGIN_SRC c
  struct buffer {
    //mechanism used for implementing the circular list of buffers
    //the list is circular because there is no perferred buffer and
    //it should be possible to get to any buffer with equal case
    struct buffer *next_chain_entry;
    char buffer_name[BUFFERNAMEMAX];

    location point;
    int cur_line;
    int num_chars;
    int num_lines;

    struct mark *mark_list;

    struct storage *contents;
    char file_name[FILENAMEMAX];
    //name of the file asscociated with the buffer, otherwise empty string
    time file_time;
    FLAG is_modified;

    struct mode *mode_list;
  }
#+END_SRC
   + mark ::
#+BEGIN_SRC c
  struct mark {
    struct mark *next_mark; //NULL indicateds the end of the chain
    mark_name name;
    location where_it_is;
    FLAG is_fixed;
  }
#+END_SRC
   + mode ::
#+BEGIN_SRC c
  struct mode {
    struct mode *next_mode;
    char *mode_name;
    status (*add_proc)();
  }
#+END_SRC
** Procedure interface definition
   + assume callee allocate data structures.
#+BEGIN_SRC c++
  //basic set-up-housekeeping call. It should perform all required one-time
  //initialization operations. No other sub-editor procedure except for
  //World_Fini can be legally called unless World_Init returns a successful
  //status.
  status World_Init(void);
  status World_Fini(void);
  status World_Save(char *file_name);
  status World_Load(char *file_name);
#+END_SRC
   + If you are creating a "stripped down" editor, the *World_Save* and *World_Load*
     routines wouldn't do anything.
#+BEGIN_SRC c
  status Buffer_Create(char *buffer_name);
  status Buffer_Clear(char *buffer_name);
  status Buffer_Delete(char *buffer_name);
  //sets the current buffer to the one specified
  status Buffer_Set_Current(char *buffer_name);
  //sets the current buffer to the next one in the chain, and it returns
  //the name of the new buffer. This mechanism allows for iterating through
  //all buffers looking for one which meets an arbitrary test.
  char *Buffer_Set_Next(void);
  status Buffer_Set_Name(char *buffer_name);
  char *Buffer_Get_Name(void);
#+END_SRC
#+BEGIN_SRC c
  status Point_Set(location loc);
  //moves the point forward(if count is positive) or backward(if negative) by
  //abs count
  status Point_Move(int count);
  location Point_Get(void);
  //return the number of the line that the point is on. Note that while
  //characters are numbered starting from zero, lines are numbered starting from
  //
  int Point_Get_Line(void);
  location Buffer_Start(void);
  location Buffer_End(void);
#+END_SRC
#+BEGIN_SRC c
  //returns 1 if loc1 is after loc2
  int Compare_Locations(location loc1, location loc2);
  //accepts a location and returns the number of characters between the
  //location and the beginning of the buffer. The point's percentage position
  //can be computed by
  //((float)Location_To_Count(Point_Get()) * 100.) / ((float)Get_Num_Chars())
  int Location_To_Count(location loc);
  //accepts a non-negative count and converts it to the corresponding location
  location Count_To_Location(int count);
#+END_SRC
#+BEGIN_SRC c
  Point_Set(Count_To_Location(count));

  status Mark_Create(mark_name *name, FLAG is_fixed);
  void Mark_Delete(mark_name name);
  status Mark_To_Point(mark_name name);
  //set the point to the location of the specified mark
  status Point_To_Mark(mark_name name);
  location Mark_Get(mark_name name);
  status Mark_Set(mark_name name, location loc);
  FLAG Is_Point_At_Mark(mark_name name);
  FLAG Is_Point_Before_Mark(mark_name name);
  FLAG Is_Point_After_Mark(mark_name name);
  //swaps the locations of the point and the specified mark
  status Swap_Point_And_Mark(mark_name);
#+END_SRC
   + example
#+BEGIN_SRC c
  status Do_Something_Over_Region(mark_name name) {
    FLAG was_before = Is_Point_Before_Mark(name);
    mark_name saved;
    status stat = OK;

    //ensure that the point is before the mark
    if (!was_before) Swap_Point_And_Mark(name);

    //remember where we started
    if (Mark_Create(&saved) != OK) {
      if (!was_before) Swap_Point_And_Mark(name);
      return NOT_OK;
    }

    //loop until get to the mark
    for (; !Is_Point_At_Mark(name); Point_Move(1)) {
      if (/*do something*/ != OK) {
        stat = NOT_OK;
        break;
      }
    }

    Point_To_Mark(saved);
    Mark_Delete(saved);

    //put the point and mark back where they started
    if (!was_before)
      Swap_Point_And_Mark(name);
    return stat;
  }
#+END_SRC
#+BEGIN_SRC c
  //return the character after the point. Its result are undefined if the point
  //is at the end of the buffer
  char Get_Char(void);
  //returns up to count characters starting from the point. It will return fewer
  //than count character if the end of the buffer is encountered.
  void Get_String(char *string, int count);
  //return the number of characters in the buffer.
  int Get_Num_Chars(void);
  int Get_Num_Lines(void);
#+END_SRC
#+BEGIN_SRC c
  void Get_File_Name(char *file_name, int size);
  status Set_File_Name(char *file_name);
  status Buffer_Write(void);
  status Buffer_Read(void);
  //inserts the contents of the specified file into the buffer at the point,
  //making any required conversions between the external and internal representations.
  status Buffer_Insert(char *file_name);
  FLAG Is_File_Changed(void);
  void Set_Modified(FLAG is modified);
  //returns the modification flag
  FLAG Get_Modified(void);
#+END_SRC
#+BEGIN_SRC c
  status Mode_Append(char *mode_name, status (*add_proc)(), FLAG is_front);
#+END_SRC
