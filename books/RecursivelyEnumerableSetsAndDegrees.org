#+TITLE: Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets
#+AUTHOR: Robert I. Soare
#+OPTIONS: _:nil
#+LATEX_HEADER: \input{preamble.tex}
#+EXPORT_FILE_NAME: ../latex/RecursivelyEnumerableSetsAndDegrees/RecursivelyEnumerableSetsAndDegrees.tex
#+LATEX_HEADER: %\\tf{\([^\}]*\)} \*\1\*
* Recursive Functions
** Formal Definitions of Computable Functions
*** Primitive Recursive Functions
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   The class of primitive recursive functions is the smallest class $\calc$ of
   functions closed under the following schema
   1. the *successor function*, $\lambda x[x+1]\in\calc$
   2. the *constant functions*, $\lambda x_1\dots x_n[m]\in\calc$, $0\le n,m$
   3. the *identity function*, $\lambda x_1\dots x_n[x_i]\in\calc$, $1\le
      i\le n$
   4. (Composition) If $g_1,\dots,g_m,h\in\calc$, then
      \begin{equation*}
      f(x_1,\dots,x_n)=h(g_1(x_1,\dots,x_n),\dots,g_m(x_1,\dots,x_n))
      \end{equation*}
      is in $\calc$ where $g_1,\dots,g_m$ are functions of $n$ variables and $h$
      is a function of $m$ variables
   5. (Primitive Recursion) If $g,h\in\calc$ and $n\ge 1$ then $f\in\calc$ where
      \begin{gather*}
      f(0,x_2,\dots,x_n)=g(x_2,\dots,x_n)\\
      f(x_1+1,x_2,\dots,x_n)=h(x_1,f(x_1,\dots,x_n),x_2,\dots,x_n)\\
      \end{gather*}
   #+END_definition


   Hence a function is primitve recursive if there is a *derivation*, namely
   a sequence $f_1,\dots,f_k=f$ s.t. for each $f_i,i\le k$ is either an initial
   function or obtained from 4 or 5.

   A predicate (relation) is *primitive recursive* if its characteristic
   function is.
*** Diagonalization and Partial Recursive Functions
   Although the primitive recursive functions include all the usual functions
   from elementary number theory they fail to include *all* computable
   functions. Each derivation of a primitive recursive function is a finite
   string of symbols from a fixed finite alphabet, and thus all derivations can
   be effectively listed. Let $f_n$ be the function corresponding to the \(n\)th
   derivation in this listing. Then the function $g(x)=f_x(x)+1$ cannot be
   primitive recursive.

   The same argument applies to any effective set of schemata which produces
   only *total* functions. /Thus to obtain all computable functions we are/
   /forced to consider computable *partial* functions./

   [[index: partial recursive]] [[index: p.r.]]
   #+ATTR_LATEX: :options [Kleene]
   #+BEGIN_definition
   label:def2.2
   The class of *partial recursive* (p.r.) functions is the least class
   obtained by closing under schemata 1 through 5 for the primitive recursive
   functions and the following schemata 6. A *total recursive* function
   (abbreviated *recursive* function) is a partial recursive function which
   is total.
   6. [@6] (Unbounded Search) If $\theta(x_1,\dots,x_n,y)$ is a partial
      recursive function of $n+1$ variables, and 
      \begin{align*}
      \psi(x_1,\dots,x_n)=\mu y[\theta&(x_1,\dots,x_n,y)\downarrow=0\\
      &\wedge (\forall z\le y)[\theta(x_1,\dots,x_n,z)\downarrow]]
      \end{align*}
   #+END_definition
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   A relation $R\subseteq \omega^n,n\ge 1$ is *recursive* (*primitive
   recursive*, has property $P$) if its characteristic function $\chi_R$ is
   recursive (primitive recursive) where $\chi_R(x_1\dots,x_n)=1$ if and only if
   $(x_1,\dots,x_n)\in R$.
   #+END_definition
*** Turing Computable Functions
   A *Turing machine* $M$ includes a two-way infinite *tape* divided into
   *cells*, a *reading head* which scans one cell of the tape at a time,
   and a finite set of internal *states* $Q=\{q_0,\dots,q_n\},n\ge 1$. Each
   cell is either blank (B) or has written on it the symbol 1. In a single step
   the machine may simultaneously
   1. change from one state to another
   2. change the scanned symbol $s$ to another symbol $s'\in S=\{1,B\}$
   3. move the reading head one cell to the right (R) or left (L)


   The operation of $M$ is controlled by a partial map 
   $\delta:Q\times S\to Q\times S\times\{R,L\}$

   The map \delta viewed as a finite set of quintuples is called a *Turing
   program*. The *input* integer $x$ is represented by a string of $x+1$
   consecutive 1's.
*** Exercises
    #+ATTR_LATEX: :options [Definition by cases]
    #+BEGIN_exercise
    label:ex2.6
    If \(g_1(x),\dots,g_n(x)\) are primitive recursive functions and
    \(R_1(x),\dots,R_n(x)\) are primitive recursive relations which are mutually
    exclusive and exhaustive show that \(f\) is primitive where \(f(x)=g_1(x)\)
    if \(R_1(x)\),\(\dots\),\(f(x)=g_n(x)\) if \(R_n(x)\)
    #+END_exercise

    #+BEGIN_proof
    \(f(x)=\sum_{i=1}^n\chi_{R_i}(x)\times g_i(x)\)
    #+END_proof
** The Basic Results
   *Church's Thesis* asserts that these functions coincide with the
   intuitively computable functions. We shall accept Church's Thesis and from
   now on shall use the terms /"partial recursive"/ /"Turing computable"/ and
   /"computable"/ interchangeably

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   Let $P_e$ be the Turing program with code number (GÃ¶del number) $e$ 
   (also called *index* $e$) in this
   listing and let $\varphi_e^{(n)}$ be the partial fucntions of $n$ variables
   computed by $P_e$, where $\varphi_e$ abbreviates $\varphi_e^{(1)}$
   #+END_definition

   #+ATTR_LATEX: :options [Padding Lemma]
   #+BEGIN_lemma
   label:lemma1.3.2
   Each partial recursive function $\varphi_x$ has $\aleph_0$ indices, and
   furthermore for each $x$ we can effectively find an infinite set $A_x$ of
   indices for the same partial function
   #+END_lemma
   

   #+BEGIN_proof
   For any program $P_x$ mentioning internal states $\{q_0,\dots,q_n\}$ add
   extraneous instructions $q_{n+1}Bq_{n+1}BR,q_{n+2}Bq_{n+2},BR,\dots$ to get
   new programs for the same functions
   #+END_proof
   #+ATTR_LATEX: :options [Normal Form Theorem (Kleene]
   #+BEGIN_theorem
   label:thm1.3.3
   There exist a predicate $T(e,x,y)$ (called the *Kleene T-predicate*) and a
   function $U(y)$ which are recursive (indeed primitive recursive) s.t.
   \begin{equation*}
   \varphi_e(x)=U(\mu y T(e,x,y))
   \end{equation*}
   #+END_theorem

   #+BEGIN_proof
   Informally, the predicate \(T(e,x,y)\) asserts that \(y\) is the code number
   of some Turing computation according to program \(P_e\) with input \(x\). To
   see whether \(T(e,x,y)\) holds we first effectively recover from \(e\) the
   Program \(P_e\); then recover from \(y\) the computation
   \(c_0,c_1,\dots,c_n\) if \(y\) codes such a computation. Now check whether
   \(c_0,\dots,c_n\) is a computation according to \(P_e\) with \(x\) as the
   input in \(c_0\). If so \(U(y)\) simply outputs the number of \(1\)'s in the
   final configuration \(c_n\).
   #+END_proof

   It follows from the Normal Form Theorem that every Turing computable partial
   function is partial recursive. To prove the converse one constructs Turing
   machines corresponding to the schemata \((1)\to(6)\).

   Note by Theorem ref:thm3.3 it follows that every partial recursive function
   can be obtained from two primitive recursive functions by *one* application
   of the \(\mu\)-operator

   #+ATTR_LATEX: :options [Enumeration Theorem]
   #+BEGIN_theorem
   label:thm3.4
   There is a p.r. function of 2 variables $\varphi_z^{(2)}(e,x)$ s.t.
   $\varphi_z^{(2)}(e,x)=\varphi_e(x)$. Indeed the Enumeration Theorem holds for
   p.r. functions of $n$ variables
   #+END_theorem
   #+BEGIN_proof
   Let $\varphi_z^{(2)}(e,x)=U(\mu y T(e,x,y))$. For
   $\varphi_z^{(n)}(e,x_1,\dots,x_{n-1})$, by \(s\)-\(m\)-\(n\) theorem, 
   \begin{equation*}
   \varphi_z^{(n)}(e,\bar{x})=
   \varphi_{s^2_{n-1}(z,e)}^{(n-1)}(\bar{x})
   \end{equation*}
   Thus we only need to make sure that $s^2_{n-1}(z,e)\in A_e$, which can be
   effectively found.
   #+END_proof
   #+ATTR_LATEX: :options [Parameter Theorem ($s$-$m$-$n$ Theorem)]
   #+BEGIN_theorem
   For every $m,n\ge 1$ there exists a 1:1 recursive function $s^m_n$ of $m+1$
   variables s.t. for all $x,y_1,y_2,\dots,y_m$
   \begin{equation*}
   \varphi_{s^m_n(x,y_1,\dots,y_m)}^{(n)}=\lambda z_1,\dots,z_n
   (\varphi_x^{(m+n)}(y_1,\dots,y_m,z_1,\dots,z_n))
   \end{equation*}
   #+END_theorem
   #+BEGIN_proof
   /(informal)/. For simplicity consider the case $m=n=1$.
   \(\varphi^{(1)}_{s^1_1(x,y)}=\lambda z(\varphi_x^{(2)}(y,z))\)
   The program
   $P_{s_1^1(x,y)}$ on input $z$ first obtains $P_x$ and then applies $P_x$ to
   input $(y,z)$. Now \(s=s_1^1\) is a recursive function by Church's Thesis
   since this is an effective procedure in \(x\) and \(y\). If \(s\) is not
   already 1:1 it may be replaced by a 1:1 recursive function \(s'\) s.t.
   \(\varphi_{s(x,y)}=\varphi_{s'(x,y)}\) by sing the padding lemma, and by
   defining \(s'(x,y)\) in increasing order of \(\la x,y\ra\), where
   \(\la x,y\ra\) is the image of \((x,y)\) under the pairing function
   #+END_proof

   #+BEGIN_remark
   Here is an interesting question in [[https://cs.stackexchange.com/questions/80837/is-smn-theorem-the-same-concept-as-currying][StackExchange]]
   #+END_remark

   The \(s\)-\(m\)-\(n\) theorem asserts that $y$ may be treated as a fixed parameter
   in the program $P_{s(x,y)}$ which operate on $z$ and furthermore that the
   index $s(x,y)$ of this program is effective in $x$ and $y$. A simple
   application of the \(s\)-\(m\)-$n$ theorem is the existence of a recursive
   function $f(x)$ s.t. $\varphi_{f(x)}=2\varphi_x$. Let
   $\psi(x,y)=2\varphi_x(y)$. By Church's Thesis
   $\psi(x,y)=\varphi_e^{(2)}(x,y)$ for some $e$. Let $f(x)=s^1_1(e,x)$

   We let $\la x,y\ra$ denote the image of $(x,y)$ under the standard pairing
   function $\frac{1}{2}(x^2+2xy+y^2+3x+y)$ which is a bijective recursive
   function from $\omega^2\to\omega$. Let $\pi_1$ and $\pi_2$ denote the inverse
   functions $\pi_1(\la x,y\ra)=x$

   For a relation \(R\subseteq\omega^n\), \(n>1\), we say that \(R\) has some
   property \(P\) iff the set \(\{\la x_1,\dots,x_n\ra:R(x_1,\dots,x_n)\}\) has
   property \(P\)

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   We write $\varphi_{e,s}(x)=y$ if $x,y,e<s$ and $y$ is the output
   $\varphi_e(x)$ in $<s$ steps of the Turing machine $P_e$. If such a $s$
   exists we say $\varphi_{e,s}(x)$ *converges*, which we write as
   $\varphi_{e,s}(x)\downarrow$, and *diverges* ($\varphi_{e,s}(x)\uparrow$).
   Similarly, we write $\varphi_e(x)\downarrow$ if $\varphi_{e,s}(x)\downarrow$
   for some $s$
   #+END_definition

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   label:thm1.3.9
   1. The set $\{\la e,x,s\ra:\varphi_{e,s}(x)\downarrow\}$ is recursive
   2. The set $\{\la e,x,y,s\ra:\varphi_{e,s}(x)=y\}$ is recursive
   #+END_theorem
   #+BEGIN_proof
   From Church's Thesis since they are all computable
   #+END_proof
*** Exercises
    #+BEGIN_exercise
    label:ex1.3.11
    Prove the following alternative definition of \(\varphi_{e,s}(x)=y\) also
    satisfies Theorem ref:thm1.3.9 as well as the convenient properties:
    \begin{equation*}
    \varphi_{e,s}(x)=y\Longrightarrow e,x,y<s
    \end{equation*}
    and
    \begin{equation*}
    (\forall s)(\exists\text{ at most one }\la e,x,y\ra)[\varphi_{e,s}(x)=y\;\&\;
    \varphi_{e,s-1}(x)\uparrow]
    \end{equation*}
    and hence
    \begin{equation*}
    (\forall s)(\exists \text{ at most one }\la e,x\ra)
    [x\in W_{e,s+1}-W_{e,s}]
    \end{equation*}

    Define \(\varphi_{e,s}(x)=y\) by recursion on \(s\) on follows. Let
    \(\varphi_{e,0}(x)\uparrow\) for all \(x\). Let \(\varphi_{e,s+1}(x)=y\) iff
    \(\varphi_{e,s}(x)=y\), or \(s=\la e,x,y,t\ra\) for some \(t>0\) and \(y\)
    is the output of \(\varphi_{e}(x)\) in \(\le t\) steps of the Turing program \(P_e\)
    #+END_exercise
** Recursively Enumerable Sets and Unsolvable Problems
   [[index: recursively enumerable]]
   [[index: r.e.]]
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A set $A$ is *recursively enumerable* (r.e.) if $A$ is the domain of
      some p.r. function
   2. let the \(e\)th r.e. set be denoted by
      \begin{equation*}
      W_e=\dom(\varphi_e)=\{x:\varphi_e(x)\downarrow\}=\{x:(\exists y)T(e,x,y)\}
      \end{equation*}
   3. $W_{e,s}=\dom(\varphi_{e,s})$
   #+END_definition

   Note that $\varphi_e(x)=x$ iff $(\exists s)[\varphi_{e,s}=y]$ and 
   $x\in W_e$ iff $(\exists s)(x\in W_{e,s})$
   
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   Let $K=\{x:\varphi_x(x)\text{ converges }\}=\{x:x\in W_x\}$
   #+END_definition
   #+ATTR_LATEX: :options []
   #+BEGIN_proposition
   $K$ is r.e.
   #+END_proposition
   #+BEGIN_proof
   $K$ is the domain of the following p.r. function
   \begin{equation*}
   \psi(x)=
   \begin{cases}
   x&\text{if } \varphi_x(x)\text{ converges},\\
   \text{undefined}&\text{otherwise}
   \end{cases}
   \end{equation*}
   Now $\psi$ is p.r. by Church's Thesis since /$\psi(x)$ can be computed by/
   /applying program $P_x$ to input $x$ and giving output $x$ only if/
   /$\varphi(x)$ converges/. Alternatively and more formally,
   $K=\dom(\theta)$ where $\theta(x)=\varphi_z^{(2)}(x,x)$ for $\varphi_z^{(2)}$
   the p.r. function defined in the Enumeration Theorem ref:thm3.4
   #+END_proof
   #+ATTR_LATEX: :options []
   #+BEGIN_corollary
   label:col1
   $K$ is not recursive
   #+END_corollary
   #+BEGIN_proof
   If $K$ had a recursive characteristic function $\chi_K$ then the following
   function would be recursive
   \begin{equation*}
   f(x)=
   \begin{cases}
   \varphi_x(x)+1&\text{if }x\in K\\
   0&\text{if }x\not\in K
   \end{cases}
   \end{equation*}
   However $f$ cannot be recursive since $f\neq\varphi_x$ for any $x$
   #+END_proof
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   $K_0=\{\la x,y\ra:x\in W_y\}$
   #+END_definition
   $K_0$ is p.r. \(K_0=\dom\theta_0\), where
   \(\theta(\la x,y\ra)=\varphi^{(2)}_z(y,x)\)

   #+ATTR_LATEX: :options []
   #+BEGIN_corollary
   label:cor4.6
   $K_0$ is not recursive
   #+END_corollary
   #+BEGIN_proof
   $x\in K$ iff $\la x,x\ra\in K_0$
   #+END_proof

   The *halting problem* is to decide for arbitrary $x$ and $y$ whether
   $\varphi_x(y)\downarrow$. Corollary ref:cor4.6 asserts the unsolvability of the
   halting problem.

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. $A$ is a *many-one reducible* (*\(m\)-reducible*) to $B$ (written
      $A\le_m B$) if there is a recursive function $f$ s.t. $f(A)\subseteq B$ and
      $f(\bar{A})\subseteq\bar{B}$, i.e. $x\in A$ iff $f(x)\in B$
   2. $A$ is *one-one reducible* (*1-reducible*) to $B$ ($A\le_1 B$) if
      $A\le_m B$ by a 1:1 recursive function
   #+END_definition

   The proof of corollary ref:cor4.6 established that $K\le_1 K_0$ via the
   function $f(x)=\la x,x\ra$
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. $A\equiv_m B$ if $A\le_m B$ and $B\le_m A$
   2. $A\equiv_1 B$ if $A\le_1 B$ and $B\le_1 A$
   3. $\deg_m(A)=\{B:A\equiv_m B\}$
   4. $\deg_1(A)=\{B:A\equiv_1 B\}$
   #+END_definition

   The equivalence classes under $\equiv_m$ and $\equiv_1$ are called the
   *m-degrees* and *1-degrees* respectively

   #+ATTR_LATEX: :options []
   #+BEGIN_proposition
   If $A\le_m B$ and $B$ is recursive then $A$ is recursive
   #+END_proposition

   #+BEGIN_proof
   $\chi_A(x)=\chi_B(f(x))$
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   label:thm4.10
   $K\le_1\text{Tot}:=\{x:\varphi_x\text{ is a total function}\}$
   #+END_theorem
   #+BEGIN_proof
   Define the function
   \begin{equation*}
   \psi(x,y)=
   \begin{cases}
   1&\text{if } x\in K\\
   \text{undefined} &\text{otherwise}
   \end{cases}
   \end{equation*}
   By \(s\)-\(m\)-\(n\) theorem, there is a 1:1 recursive function $f$ s.t.
   $\varphi_{f(x)}(y)=\psi(x,y)$. Choose $e$ s.t. $\varphi_e(x,y)=\psi(x,y)$ 
   since \psi is p.r. and
   define $f(x)=s_1^1(e,x)$. Note that
   \begin{align*}
   &x\in K\Longrightarrow \varphi_{f(x)}=\lambda y[1]\Longrightarrow\varphi_{f(x)}\text{ total}
   \Longrightarrow f(x)\in\text{Tot}\\
   &x\not\in K\Longrightarrow\varphi_{f(x)}=\lambda y[\text{undefined}]\Longrightarrow
   \varphi_{f(x)}\text{ not total}\Longrightarrow f(x)\not\in\text{Tot}
   \end{align*}
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   A set $A\subseteq\omega$ is an *index set* if for all $x$ and $y$
   \begin{equation*}
   (x\in A\wedge\varphi_x=\varphi_y)\Longrightarrow y\in  A
   \end{equation*}
   #+END_definition
   
   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   If $A$ is a nontrivial index set, i.e., $A\neq \emptyset,\omega$, then either
   $K\le_1 A$ or $K\le_1\overline{A}$
   #+END_theorem

   #+BEGIN_proof
   Choose $e_0$ s.t. $\varphi_{e_0}(y)$ is undefined for all $y$. If
   $e_0\in\overline{A}$, then $K\le_1 A$ as follows. Since $A\neq\emptyset$ we can
   choose $e_1\in A$. Now $\varphi_{e_1}\neq\varphi_{e_0}$ because $A$ is an
   index set. By \(s\)-\(m\)-\(n\) theorem define a 1:1 recursive function $f$
   s.t.
   \begin{equation*}
   \varphi_{f(x)}(y)=
   \begin{cases}
   \varphi_{e_1}(y)&x\in K\\
   \text{undefined}&x\not\in K
   \end{cases}
   \end{equation*}
   Now
   \begin{align*}
   &x\in K\Longrightarrow\varphi_{f(x)}=\varphi_{e_1}\Longrightarrow f(x)\in A\\
   &x\not\in K\Longrightarrow\varphi_{f(x)}=\varphi_{e_0}\Longrightarrow
   f(x)\in\overline{A}
   \end{align*}
   #+END_proof

   It's possible that both $K\le_1 A$ and $K\le_1\overline{A}$ for an index set
   $A$, for example if $A=\text{Tot}$
   #+ATTR_LATEX: :options [Rice's Theorem]
   #+BEGIN_corollary
   label:cor1.4.13
   Let $\calc$ be any class of partial recursive functions. Then
   $\{n:\varphi_n\in\calc\}$ is recursive iff $\calc=\emptyset$ or $\calc$ is
   the set of all partial recursive functions
   #+END_corollary
   #+BEGIN_proof
   $\calc$ is an index set and hence is trivial.
   #+END_proof
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   \begin{align*}
   &K_1=\{x:W_x\neq\emptyset\}\\
   &\text{Fin}=\{x:W_x\text{ is finite}\}\\
   &\text{Inf}=\omega-\text{Fin}=\{x:W_x\text{ is infinite}\}\\
   &\text{Tot}=\{x:\varphi_x\text{ is total}\}=\{x:W_x=\omega\}\\
   &\text{Con}=\{x:\varphi_x\text{ is total and constant}\}\\
   &\text{Cof}=\{x:W_x\text{ is cofinite}\}\\
   &\text{Rec}=\{x:W_x\text{ is recursive}\}\\
   &\text{Ext}=\{x:\varphi_x\text{ is extendible to a total recursive function}\}\\
   \end{align*}
   #+END_definition
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   An r.e. set $A$ is *1-complete* if $W_e\le_1 A$ for every r.e. set $W_e$
   #+END_definition

   $K_0$ is 1-complete because $x\in W_e$ iff $\la x,e\ra\in K_0$

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   Let $A$ *join* $B$ written $A\oplus B$ be
   \begin{equation*}
   \{2x:x\in A\}\cup\{2x+1:x\in B\}
   \end{equation*}
   #+END_definition
*** Exercises
    #+BEGIN_exercise
    label:4.17
    1. $A\le_m A\oplus B$ and $B\le_m A\oplus B$
    2. if $A\le_m C$ and $B\le_m C$ then $A\oplus B\le_m C$
   #+END_exercise

    #+BEGIN_proof
    1.
    2. Easy
    #+END_proof

   #+BEGIN_exercise
   label:ex4.18
   $K\equiv_1 K_0\equiv_1 K_1$
   #+END_exercise
   #+BEGIN_proof
   $K\le_1 A$ for $A=K_1,\text{con}$ or
   $\text{Inf}$.

   $K_0\le K$ for the same reason.

   For \(K\le K_1\)
   \begin{equation*}
   \varphi_{f(x)}(y)=
   \begin{cases}
   x&x\in K\\
   \text{undefined}&x\not\in K
   \end{cases}
   \end{equation*}

   For \(K_0\le_1 K\), the same (find a \(x\) s.t. \(x\in W_x\))

   Also note that \(K\) and \(K_1\) are 1-complete
   #+END_proof

   #+BEGIN_exercise
   label:ex4.19
   Prove directly (without Rice's theorem) that $K\le_1\text{Fin}$
   #+END_exercise
   #+BEGIN_proof
   Let
   \begin{equation*}
   \varphi_{f(x)}(s)=
   \begin{cases}
   0&x\not\in K_s\\
   \text{undefined}&x\in K_s
   \end{cases}
   \end{equation*}
   where $K_s=W_{e,s}$ for some $e$ s.t. $K=W_e$. If $x\in K$, then
   $\dom(\varphi_{f(x)})$ is finite
   #+END_proof
   #+BEGIN_exercise
   For any $x$ show that $\overline{K}\le_1\{y:\varphi_x=\varphi_y\}$ and
   $\overline{K}\le_1\{y:W_x=W_y\}$
   #+END_exercise
   #+BEGIN_proof
   Use the method of exercise ref:ex4.19. If $x\not\in W_x$, then
   $\dom(\varphi_{f(x)})=\omega$.
   #+END_proof
   #+BEGIN_exercise
   $\text{Ext}\neq\omega$
   #+END_exercise
   #+BEGIN_proof
   Use $K$. If $\psi(x)$ can be extended to a recursive function, then $K$ would
   be recursive.
   #+END_proof

   #+BEGIN_exercise
   label:ex1.4.22
   1. Disjoints sets $A$ and $B$ are *recursively inseparable* if there is no
      recursive set $C$ s.t. $A\subseteq C$ and $C\cap B=\emptyset$. Show that
      there exists disjoint r.e. sets which are recursively inseparable.
   2. Give an alternative proof that $\text{Ext}\neq\omega$
   3. For $A$ and $B$ as in part 1, prove that $K\equiv_1 A$ and $K\equiv_1 B$
   #+END_exercise
   #+BEGIN_proof
   1. Consider $A=\{x:\varphi_x(0)=0\}$ and $B=\{x:\varphi_x(0)=1\}$.
   2. corollary from 1.
   3.
   #+END_proof

   #+BEGIN_exercise
   A set $A$ is *cylinder* if $(\forall B)[B\le_m A\Longrightarrow B\le_1 A]$
   1. Show that any index set is a cylinder
   2. Show that any set of the form $A\times\omega$ is a cylinder
   3. Show that $A$ is a cylinder iff $A\equiv_1 B\times\omega$ for some set $B$

   #+END_exercise

   #+BEGIN_proof
   1. If different $x,y\in B$ and $f(x)=f(y)$, we could just add redundent
      computation and $\varphi_{f(x)}=\varphi_{f(y)}$
   2. to make sure images are different by \omega
   3.
   #+END_proof

   #+BEGIN_exercise
   Show that the partial recursive functions are not closed under \mu, i.e.,
   there is a p.r. function \psi s.t. $\lambda x[\mu y[\psi(x,y)=0]]$ is not p.r.
   #+END_exercise
   #+BEGIN_proof
   $\psi(x,y)=0$ if $y=1$ or $y=0$ and $\varphi_x(x)\downarrow$.
   #+END_proof
   #+BEGIN_exercise
   If $A$ is recursive and $B,\overline{B}$ are each $\neq\emptyset$, then
   $A\le_m B$
   #+END_exercise
   #+BEGIN_proof
   choose elements $b\in B$ and $b'\in\overline{B}$. Then
   \begin{equation*}
   \psi_{f(x)}(s)=
   \begin{cases}
   b&x\in A\\
   b'&x\not\in A\\
   \end{cases}
   \end{equation*}
   #+END_proof
   #+BEGIN_exercise
   Prove that $\text{Inf}\equiv_1\text{Tot}\equiv_1\text{Con}$
   #+END_exercise
   #+BEGIN_proof
   $\text{Tot}\equiv_1\text{Con}$ is obvious. For $\text{Inf}\le_1\text{Con}$,
   define
   \begin{equation*}
   \psi(e,x)=
   \begin{cases}
   0&\text{if }(\exists y>x)[\varphi_e(y)\downarrow]\\
   \uparrow&\text{otherwise}
   \end{cases}
   \end{equation*}
   #+END_proof

   #+BEGIN_exercise
   $\text{Fin}\le_1\text{Cof}$
   #+END_exercise
   #+BEGIN_proof
   \begin{equation*}
   \varphi_{f(e)}(s)=
   \begin{cases}
   \uparrow&\text{if } W_{e,s+1}-W_{e,s}\neq\emptyset\\
   0&\text{otherwise}
   \end{cases}
   \end{equation*}
   #+END_proof

** Recursive Permutation and Myhill's Isomorphism Theorem
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A *recursive permutation* is a 1:1, recursive function from \omega to \omega
   2. A property of set is *recursively invariant* if it's invariant under all
      recursive permutation
   #+END_definition
   Examples:
   1. $A$ is r.e. (\(A\le_1\im(A)\))
   2. $A$ has cardinality n
   3. $A$ is recursive
      

   Properties that not recursively invariant:
   1. $2\in A$
   2. $A$ contains the even integers
   3. $A$ is an index set


   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   A is *recursively isomorphic* to $B$ (written $A\equiv B$) if there is a
   recursive permutation $p$ s.t. $p(A)=B$
   #+END_definition

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   The equivalence classes under $\equiv$ are called *recursive isomorphism types*
   #+END_definition

   #+ATTR_LATEX: :options [Myhill Isomorphism Theorem]
   #+BEGIN_theorem
   label:thm5.4
   $A\equiv B\Longleftrightarrow A\equiv_1 B$
   #+END_theorem
   #+BEGIN_proof
   ($\Longrightarrow$) trivial.

   ($\Longleftarrow$) Let $A\le_1 B$ via $f$ and $B\le_1 A$ via $g$. We define a
   recursive permutation $h$ by stages so that $h(A)=B$. We let
   $h=\bigcup_sh_s$, where $h_0=\emptyset$ and $h_s$ is that portion of $h$
   defined by the end of stage $s$. Assume $h_s$ is given so that in particular
   we can effectively check for membership in $\dom{h_s}$ and $\ran(h_s)$ which
   we both assume finite

   /Stage/ $s+1=2x+1$. Assume that $h_s$ is $1:1$, $\dom{h_s}$ is finite and $y\in
   A$ iff $h_s(y)\in B$ for all $y\in\dom{h_s}$.If $h_s(x)$ is defined, do
   nothing. Otherwise enumerate the set
   $\{f(x),f(h_s^{-1}f(x)),\dots,f(h_s^{-1}f)^n(x),\dots\}$ until the fist
   element $y$ not yet in $\ran(h_s)$. Define $h_{s+1}(x)=y$. $y$ must exist
   since $f$ and $h_s$ are $1:1$ and $x\not\in\dom{h_s}$

   /Stage/ $s+1=2x+2$. Define $h^{-1}(x)$ similarly with $f,h_s,\dom$ and
   $\ran$ replaced by $g,h_s^{-1},\ran,\dom$ respectively
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   A function $f$ *dominates* a function $g$ if $f(x)\ge g(x)$ for almost every
   (all but finitely many) $x\in\omega$
   #+END_definition

*** Exercises
   #+ATTR_LATEX: :options [$\times$]
   #+BEGIN_exercise
   Prove that the primitive recursive permutations do not form a group under composition
   #+END_exercise
   #+BEGIN_proof
   Define $g(x)=\mu yT(e,x,y)$. $g$ dominates all primitive recursive functions
   since $y\ge U(y)$ for all $y$. Suppose $f$ is a primitive recursive
   permutation and $f(g(x))=x$ if $x$ is even. Note that given $y$ we can
   primitively recursively compute whether there is an $x$ s.t. $g(x)=y$
   #+END_proof

   #+BEGIN_exercise
   label:ex1.5.8
   Let $\omega=\bigcup_nA_n=\bigcup_nB_n$ where the sequences
   $\{A_n\}_{n\in\omega}$ and $\{B_n\}_{n\in\omega}$ are each pairwise disjoint.
   Let $f$ and $g$ be 1:1 recursive functions s.t. $f(A_n)\subseteq B_n$ and
   $g(B_n)\subseteq A_n$ for all $n$. Show that the construction of Theorem
   ref:thm5.4 produces a recursive permutation $h$ s.t. $h(A_n)=B_n$ for all $n$
   #+END_exercise

   #+BEGIN_proof
   /stage/ \(s+1=2x+1\): assume \(h_s\) is 1:1, \(\dom h_s\) is finite. Hence
   there is \(a\in\omega\) not in \(\dom h_s\). Then by...
   #+END_proof

   #+ATTR_LATEX: :options [Rogers]
   #+BEGIN_exercise
   label:ex1.5.9
   Let \(\calp\) be the class of partial recursive functions of one variable. A
   *numbering* of the p.r. function is a map \pi from \omega onto \(\calp\). The
   numbering \(\{\varphi_e\}_{e\in\omega}\) is called the *standard numbering*.
   Let \(\hat{\pi}\) be another numbering and let \(\psi_e\) denote
   \(\hat{\pi}(e)\). Then \(\hat{\pi}\) is an *acceptable* numbering if there
   are recursive functions \(f\) and \(g\) s.t.
   1. \(\varphi_{f(x)}=\psi_x\)
   2. \(\psi_{g(x)}=\varphi_x\)


   Show that for any acceptable numbering \(\hat{\pi}\), there is a recursive
   permutation \(p\) of \omega s.t. \(\varphi_x=\psi_{p(x)}\) for all \(x\)
   #+END_exercise

   #+BEGIN_proof
   Define \(e_1\sim e_2\) if \(\varphi_{e_1}\) and \(\varphi_{e_2}\) computes
   the same p.r. function. Then we get an enumeration
   \(([e_i])_{i\in\omega}=A/\sim\). Define \(A_i=[e_i]\). Obviously
   \(f(A_i)\subseteq B_i\) and vice versa

   By exercise ref:ex1.5.8 with appropriate definitions of \(A_n\) and \(B_n\)
   it suffices to convert \(f\) and \(g\) to a 1:1 recursive functions \(f_1\)
   and \(g_1\) satisfying (1) and (2).

   To define \(f_1\) from \(f\) use the Padding Lemma ref:lemma1.3.2. To define
   \(g_1(x)\) we must be able (uniformly in \(x\))  to effectively generate an
   infinite set \(S_x\) of indices s.t. for each \(y\in S_x\)
   \(\psi_y=\psi_{g(x)}\). Take any two recursively inseparable r.e. sets \(A\)
   and \(B\), such as those of Exercise ref:ex1.4.22, and define
   \begin{equation*}
   \varphi_{k(x,y)}(z)=
   \begin{cases}
   \varphi_x(z)&y\in A\\
   0&y\in B\\
   \text{undefined}&\text{otherwise}
   \end{cases}
   \end{equation*}
   and similarly \(\varphi_{l(x,y)}\) with 1 in place of 0. Let
   \(C_x=\{k(x,y):y\in A\}\) and \(D_x=\{l(x,y):y\in A\}\). If
   \(\varphi_x\neq\lambda z[0]\), then \(g(C_x)\) cannot be finite or else \(A\)
   and \(B\) are recursively separable. Hence \(S_x=g(C_x)\cup g(D_x)\) is
   infinite. Note we do not have to know this in order to see that \(S_x\) is infinite
   #+END_proof

* Fundamentals of Recursively Enumerable Sets and the Recursion Theorem
** Equivalent Definitions of Recursively Enumerable Sets
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A set \(A\) is a *projection* of some relation
      \(R\subseteq\omega\times\omega\) if \(A=\{x:(\exists y)R(x,y)\}\)
   2. A set \(A\) is in *\(\Sigma_1\)-form* (abbreviated "A is \(\Sigma_1\)") if
      \(A\) is the projection of some recursive relation \(R\subseteq\omega\times\omega\).
   #+END_definition

   #+ATTR_LATEX: :options [Normal Form Theorem for r.e. sets]
   #+BEGIN_theorem
   label:thm2.1.2
   A set \(A\) is r.e. iff \(A\) is \(\Sigma_1\)
   #+END_theorem

   #+BEGIN_proof
   If \(A\) is r.e., then \(A=W_e\) for some \(e\). Hence
   \begin{equation*}
   x\in W_e\Leftrightarrow(\exists s)[x\in W_{e,s}]\Leftrightarrow
   (\exists s)T(e,x,s)
   \end{equation*}
   and \(T(e,x,s)\) is primitive recursive

   Let \(A=\{x:(\exists y)R(x,y)\}\), where \(R\) is recursive. Then
   \(A=\dom\psi\), where \(\psi(x)=(\mu y)R(x,y)\)
   #+END_proof

   #+ATTR_LATEX: :options [Quantifier Contraction Theorem]
   #+BEGIN_theorem
   label:thm2.1.3
   If there is a recursive relation
   \begin{equation*}
   R\subseteq\omega^{n+1}
   \end{equation*}
   and
   \begin{equation*}
   A=\{x:(\exists y_1)\dots(\exists y_n)R(x,y_1,\dots,y_n)\}
   \end{equation*}
   then \(A\) is \(\Sigma_1\)
   #+END_theorem

   #+BEGIN_proof
   Define the recursive relation \(S\subseteq \omega^2\) by
   \begin{equation*}
   S(x,z)\Leftrightarrow R(x,(z)_1,\dots,(z)_n)
   \end{equation*}
   where \(z=p_1^{(z)_1}\dots p_k^{(z)_k}\)
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_corollary
   label:cor2.1.4
   The projection of an r.e. relation is r.e.
   #+END_corollary

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   The *graph* of a (partial) function \psi is the relation
   \begin{equation*}
   (x,y)\in\graph\psi\Leftrightarrow\psi(x)=y
   \end{equation*}
   #+END_definition

   Using Theorem ref:thm1.3.9 the following sets and relations are r.e.:
   1. \(K=\{e:e\in W_e\}=\{e:(\exists s,y)[\varphi_{e,s}(e)=y]\}\)
   2. \(K_0=\{\la x,e\ra:x\in W_e\}=\{\la x,e\ra:(\exists s,y)[\varphi_{e,s}(x)=y]\}\)
   3. \(K_1=\{e:W_e\neq0\}=\{e:(\exists s,x)[x\in W_{e,s}]\}\)
   4. \(\im\varphi_e=\{y:(\exists s,x)[\varphi_{e,s}(x)=y]\}\)
   5. \(\graph\varphi_e=\{(x,y):(\exists s)[\varphi_{e,s}(x)=y]\}\)


   #+ATTR_LATEX: :options [Uniformization Theorem]
   #+BEGIN_theorem
   label:thm2.1.6
   If \(R\subseteq\omega^2\) is an r.e. relation, then there is a p.r. function
   \psi (called a *selector function* for \(R\)) s.t.
   \begin{equation*}
   \psi(x)\downarrow\Leftrightarrow(\exists y)R(x,y)
   \end{equation*}
   and in this case \((x,\psi(x))\in R\)
   #+END_theorem

   #+BEGIN_proof
   Since\(R\) is r.e. and hence \(\Sigma_1\), there is a recursive relation
   \(S\) s.t. \(R(x,y)\) holds iff \((\exists z)S(x,y,z)\). Define the p.r.
   function
   \begin{equation*}
   \theta(x)=(\mu u)S(x,(u)_1,(u)_2)
   \end{equation*}
   and set \(\psi(x)=(\theta(x))_1\)
   #+END_proof

   #+ATTR_LATEX: :options [Graph Theorem]
   #+BEGIN_theorem
   label:thm2.1.7
   A partial function \psi is partial recursive iff its graph is r.e.
   #+END_theorem

   #+BEGIN_proof
   If the graph of \psi is r.e., then \psi is its own selector function.

   If \psi is p.r., there is \(e\) s.t. \(\varphi_e=\psi\)
   #+END_proof

   #+ATTR_LATEX: :options [Listing Theorem]
   #+BEGIN_theorem
   label:thm2.1.8
   A set \(A\) is r.e. iff \(A=\emptyset\) or \(A\) is the range of a total
   recursive function.. Furthermore, \(f\) can be found uniformly in an index
   for \(A\) as explained in Exercise ref:ex2.1.25
   #+END_theorem

   #+BEGIN_proof
   Let \(A=W_e\neq\emptyset\). Find the least integer \(\la a,t\ra\) s.t
   \(a\in W_{e,t}\). Define the recursive function \(f\) by
   \begin{equation*}
   f(\la s,t\ra)=
   \begin{cases}
   x&x\in W_{e,s+1}-W_{e,s}\\
   a&\text{otherwise}
   \end{cases}
   \end{equation*}
   Clearly \(A=\im f\).

   If \(A\) is the range of a total recursive function, \(A\) is \(\Sigma_1\)
   #+END_proof

   #+ATTR_LATEX: :options [Union Theorem]
   #+BEGIN_theorem
   label:thm2.1.9
   The r.e. sets are closed under union and intersection uniformly effectively,
   namely there are recursive functions \(f\) and \(g\) s.t.
   \(W_{f(x,y)}=W_x\cup W_y\), and \(W_{g(x,y)}=X_x\cap W_y\)
   #+END_theorem

   #+BEGIN_proof
   Using the \(s\)-\(m\)-\(n\) Theorem define \(f(x,y)\) by enumerating
   \(z\in W_{f(x,y)}\) if \((\exists s)[z\in W_{x,s}\cup W_{y,s}]\)
   #+END_proof

   #+ATTR_LATEX: :options [Reduction Principle for r.e. sets]
   #+BEGIN_corollary
   label:cor2.1.10
   Given any two r.e. sets \(A\) and \(B\), there exist r.e. sets
   \(A_1\subseteq A\) and \(B_1\subseteq B\) s.t. \(A_1\cap B_1=\emptyset\) and
   \(A_1\cup B_1=A\cup B\)
   #+END_corollary

   #+BEGIN_proof
   Define the relation \(R:=A\times\{0\}\cup B\times{1}\) which is r.e. by
   Theorem ref:thm2.1.9. By the Uniformization Theorem ref:thm2.1.6, let \psi be
   the p.r. selector function for \(R\). Let \(A_1=x:\psi(x)=0\) and
   \(B_1=x:\psi(x)=1\) 
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   A set \(A\) is in *\(\Delta_1\)-form* (abbreviated "\(A\) is \(\Delta_1\)")
   if both \(A\) and \(\bar{A}\) is \(\Sigma_1\).
   #+END_definition

   #+ATTR_LATEX: :options [Complementation Theorem]
   #+BEGIN_theorem
   label:thm2.1.12
   A set \(A\) is recursive iff both \(A\) and \(\bar{A}\) are r.e. (i.e., iff \(A\in\Delta_1\))
   #+END_theorem

   #+BEGIN_proof
   Let \(A=W_e,\bar{A}=W_i\). Define the recursive function
   \begin{equation*}
   f(x)=(\mu s)[x\in W_{e,s}\vee x\in W_{i,s}]
   \end{equation*}
   Then \(x\in A\) iff \(x\in W_{e,f(x)}\), so \(A\) is recursive
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_corollary
   label:cor2.1.13
   \(\bar{K}\) is not r.e.
   #+END_corollary

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A *lattice* \(\call=(L;\le,\vee,\wedge)\) is a partially ordered set
      (poset) in which any two elements have a least upper bound and greatest
      lower bound. If \(a\) and \(b\) are elements of a lattice \(\call\),
      \(a\vee b\) denote the least upper bound (lub) of \(a\) and \(b\),
      \(a\wedge b\) the greatest lower bound (glb). If \(\call\) contains a
      least element and greatest element these are called the *zero* element and
      *unit* element 1. In such a lattice \(a\) is the *complement* of \(b\) if
      \(a\vee b=1\)
   2. A lattice is *distributive* if all its elements satisfy the distributive
      laws
      \((a\vee b)\wedge c=(a\wedge c)\vee(b\wedge c)\) and
      \((a\wedge b)\vee c=(a\vee c)\wedge(b\vee c)\)
   3. A lattice is *complemented* if every element has a complement
   4. A poset closed under suprema but not necessarily under infima is an
      *upper semi-lattice*
   5. \(\calm=(\la M;\le,\vee,\wedge)\) is a *sublattice* of \(\call\) if
      \(M\subseteq L\) and \(M\) is closed under the operations \(\vee\) and
      \(\wedge\) in \(\call\)
   6. A nonempty subset \(I\subseteq L\) forms an *ideal*
      \(\cali=(I,\le,\wedge,\vee)\) of \(\call\) if \(I\) satisfies the
      conditions
      1. \([a\in L\;\&\;a\le b\in I]\Longrightarrow a\in I\)
      2. \([a\in I\;\&\;b\in I]\Longrightarrow a\vee b\in I\)
   7. A subset \(D\subseteq L\) forms a *filter* \(\cald=(D;\le,\wedge,\vee)\)
      of \(\call\) if it satisfies the dual conditions
      1. \([a\in L\;\&\; a\ge b\in D]\Longrightarrow a\in D\)
      2. \([a\in D\;\&\; b\in D]\Longrightarrow a\wedge b\in D\)
   8. Let \(\call\) be an upper semi-lattice. The definitions of ideal and
      filter are the same except that we require (2) only when \(a\wedge b\)
      exists. Furthermore, we say \(\cald\) is a *strong filter* in \(\call\) if
      \(\cald\) satisfies (1) and also:
      1. \([a\in\cald\;\&\;b\in\cald]\Leftrightarrow(\exists c\in\cald)
         [c\le a\;\&\;c\le b]\)
   #+END_definition

   The collection of all subsets of \omega forms a Boolean algebra,
   \(\caln=(2^\omega;\subseteq,\cup,\cap)\) with \(\emptyset\) as least element
   and \omega as the greatest element. The finite sets form an ideal \(\calf\)
   of \(\caln\) and the cofinite sets form a filter \(\calc\) in \(\caln\)


   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. By Theorem ref:thm2.1.9 the r.e. sets form a distributive lattice
      \(\cale\) under inclusion with greatest element \omega and least element \(\emptyset\)
   2. By Theorem ref:thm2.1.12 an r.e. set \(A\in\cale\) is recursive iff
      \(\bar{A}\in\cale\). Hence the recursive sets form a Boolean algebra \(\calr\subseteq\cale\).
   #+END_definition
*** exercise

    #+BEGIN_exercise
    label:2.1.16
    1. Prove that \(A\le_m B\) and \(B\) r.e. imply \(A\) r.e.
    2. Show that \(\Fin\) and \(\Tot\) are not r.e.
    3. Show that \(\Cof\) is not r.e.
    #+END_exercise

    #+BEGIN_proof
    1. Let \(f:A\to B\), then \(A=\{a:(\exists b)((a,b)\in\graph f)\}\) ?
    #+END_proof

    #+BEGIN_exercise
    label:2.1.17
    Prove that if \(A\) is r.e. and \psi is p.r. then \(\psi(A)\) is r.e. and
    \(\psi^{-1}(A)\) is r.e.
    #+END_exercise

    #+BEGIN_proof
    Let \(\psi=\varphi_e\) and \(\psi(A)=\{y: (\exists s,x)\varphi_{e,s}(x)=y\}\)
    #+END_proof

    #+BEGIN_exercise
    label:ex2.1.18
    Prove that if \(f\) is recursive, then \(\graph f\) is recursive
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.19
    A function \(f\) is *increasing* if \(f(x)<f(x+1)\) for all \(x\). Show that
    an infinite set \(A\) is recursive iff \(A\) is the range of an increasing
    recursive function
    #+END_exercise

    #+BEGIN_proof
    \begin{equation*}
    \chi_A(x)=
    \begin{cases}
    1&(\exists y<x)f(y)=x\\
    0
    \end{cases}
    \end{equation*}
    #+END_proof

    #+BEGIN_exercise
    label:ex2.1.20
    Prove that any infinite r.e. set is the range of a 1:1 recursive function
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.21
    Prove that every infinite r.e. set contains an infinite recursive subset
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.22
    A set \(A\) is *co-r.e.* (or equivalently \(\Pi_1\)) if \(\bar{A}\) is r.e.
    Use Exercise ref:ex1.4.22 to prove that the reduction principle fails for \(\Pi_1\) sets
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.23
    The *separation principle* holds for a class \(\calc\) of sets if for every
    \(A,B\in\calc\) s.t. \(A\cap B=\emptyset\) there exists \(C\) s.t.
    \(C,\bar{C}\in\calc\), \(A\subseteq C\) and \(B\subseteq\bar{C}\). By
    Exercise ref:ex1.4.22 the separation fails  for r.e. sets. Use Corollary
    ref:cor2.1.10 to show that the separation principle holds for co-r.e. sets
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.24
    Prove that if \(A\le_1 B\) and \(A\) and \(B\) are r.e. and \(A\) is
    infinite then \(A\le_1 B\) via some \(f\) s.t. \(f(A)=B\)
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.25
    Show that the proof of Theorem ref:thm2.1.8 is uniform in \(e\) in the sense
    that there is a p.r. function \(\psi(e,y)\) s.t. if \(W_e\neq0\) then
    \(\lambda y\psi(e,y)\) is total and \(W_e=\{\psi(e,y):y\in\omega\}\). 
    #+END_exercise
** Uniformity and Indices for Recursive and Finite Sets
   A theorem will be said to hold *uniformly* if such an effective procedure
   exists.

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. We say that \(e\) is *\(\Sigma_1\)-index* (r.e. index) for a set \(A\) if
      \(A=W_e=\{x: (\exists y)T(e,x,y)\}\)
   2. \(\la e,i\ra\) is a *\(\Delta_1\)-index* for a recursive set \(A\) if
      \(A=W_e\) and \(\bar{A}=W_i\)
   3. \(e\) is a *\(\Delta_0\)-index* (*characteristic index*) for \(A\) if
      \(\varphi_e\) is the characteristic function for \(A\)
   #+END_definition

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   label:thm2.2.2
   There is no p.r. function \psi s.t. if \(W_x=A\) and \(A\) is recursive then
   \(\psi(x)\) converges and \(W_{\psi(x)}=\bar{A}\). (There is no uniformly
   effective way to pass from \(\Sigma_1\)-indices to \(\Delta_0\)-indices for
   recursive sets)
   #+END_theorem

   #+BEGIN_proof
   Define the recursive function \(f\) by
   \begin{equation*}
   W_{f(x)}=
   \begin{cases}
   \omega&x\in K\\
   \emptyset
   \end{cases}
   \end{equation*}
   Now
   \begin{align*}
   &x\in K\Longrightarrow W_{f(x)}=\omega\Longrightarrow W_{\psi f(x)}=\emptyset\\
   &x\not\in K\Longrightarrow W_{f(x)}=\emptyset\Longrightarrow W_{\psi f(x)}=\omega\\
   \end{align*}
   Hence
   \begin{equation*}
   x\in\bar{K}\Longleftrightarrow W_{\psi f(x)}\neq\emptyset\Longleftrightarrow
   (\exists y,s)[y\in W_{\psi f(x),s}]
   \end{equation*}
   so \(\bar{K}\) is \(\Sigma_1\) and hence r.e., contradicting Corollary ref:cor2.1.13
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_corollary
   label:cor2.2.3
   The recursive sets are closed under \(\cup,\cap\) and complementation. The
   closure under \(\cup\) and \(\cap\) is uniformly effective w.r.t. both
   \(\Sigma_1\) and \(\Delta_1\)-indices. The closure under complementation is
   uniformly effective w.r.t. \(\Delta_1\)-indices
   #+END_corollary

   A finite set, being recursive, has both a \(\Sigma_1\)-index and
   \(\Delta_0\)-index.

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. Given a finite set \(A=\{x_1,\dots,x_k\}\), where \(x_1<x_2<\dots<x_k\),
      the number \(y=2^{x_1}+\dots+2^{x_k}\) is the *canonical index* of \(A\).
      Let \(D_y\) denote finite set with canonical index \(y\) and \(D_0\)
      denote \(\emptyset\)
   2. A sequence \(\{D_{f(x)}\}_{x\in\omega}\) for some recursive function \(f\)
      is called a *recursive sequence* or a *strong array* of finite sets.
   #+END_definition

   There is no p.r. function \psi s.t. if \(\varphi_x\) is the characteristic
   function of \(D_y\), then \(\psi(x)\) converges and \(\psi(x)=\abs{D_y}\).
   (If \psi exists, define \(\varphi_{f(x)}(s)=1\) if \(x\in K_{s+1}-K_s\) and
   \(\varphi_{f(x)}(s)=0\) otherwise. Thus \(\psi\circ f\) is actually the
   characteristic function of \(K\))

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A sequence \(\{V_n\}_{n\in\omega}\) of r.e. sets is *uniformly r.e.*
      (*u.r.e*), also called *simultaneously r.e.* (*s.r.e.*) if there is a
      recursive function \(f\) s.t. \(V_n=W_{f(n)}\) for all \(n\)
   2. A sequence \(\{V_n\}_{n\in\omega}\) of recursive sets is *uniformly
      recursive* if there is a recursive function \(g(x,n)\) s.t.
      \(\lambda x[g(x,n)]\) is the characteristic function of \(V_n\) for all \(n\)
   #+END_definition

   From now on we assume that we have define \(\varphi_{e,s}\) and \(W_{e,s}\)
   using Exercise ref:ex1.3.11

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   A *recursive enumeration* (usually called simply an *enumeration*) of an r.e.
   set \(A\) consists of a strong array \(\{A_s\}_{s\in\omega}\) (of finite
   sets) s.t. \(A_s\subseteq A_{s+1}\) and \(A=\bigcup_s A_s\)
   #+END_definition

   For example, \(\{W_{e,s}\}_{s\in\omega}\) is an enumeration of \(W_e\)

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A *simultaneous (recursive) enumeration* of a u.r.e. sequence
      \(\{V_n\}_{n\in\omega}\) of r.e. sets is a strong array
      \(\{V_{n,s}\}_{n,s\in\omega}\) s.t. for all \(s,n\in\omega\)
      1. \(V_{n,s}\subseteq V_{n,s+1}\)
      2. \(\abs{V_{n,s+1}-V_{n,s}}\le1\)
      3. \(V_n=\bigcup_{s\in\omega}V_{n,s}\)
   2. A *standard enumeration* (of the r.e. sets) is a simultaneous enumeration
      of \(\{V_n\}_{n\in\omega}\) where \(\{V_n\}_{n\in\omega}\) is some
      acceptable numbering of the r.e. sets as defined in Exercise ref:ex1.5.9
   #+END_definition

   For example, an easy way to give a simultaneous enumeration of any u.r.e.
   sequence \(\{V_n\}_{n\in\omega}\) is to choose a 1:1 recursive function \(f\)
   with range \(\{\la x,n\ra:x\in V_n\}\) and to define
   \begin{equation*}
   V_{n,s}=\{x: (\exists t<s)[f(t)=\la x,n\ra]\}
   \end{equation*}

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   Let \(\{X_s\}_{s\in\omega}\) and \(\{Y_s\}_{s\in\omega}\) be recursive
   enumeration of r.e. sets \(X\) and \(Y\)
   1. Define \(X\setminus Y=\{z: (\exists s)[z\in X_s-Y_s]\}\), the elements
      enumerated in \(X\) before (if ever) being enumerated in \(Y\)
   2. Define \(X\searrow Y=(X\setminus Y)\cap Y\), the elements enumerated in
      \(X\) and later in \(Y\)
   #+END_definition
*** Exercises
    #+BEGIN_exercise
    label:2.2.10
    1. Given recursive enumeration \(\{X_s\}_{s\in\omega}\) and
       \(\{Y_s\}_{s\in\omega}\) of r.e. sets \(X\) and \(Y\) prove that both
       \(X\setminus Y\) and \(X\searrow Y\) are r.e. sets
    2. Prove that \(X\setminus Y=(X-Y)\cup(X\searrow Y)\)
    3. Prove that if \(X-Y\) is nonrecursive then \(X\searrow Y\) is infinite
    4. Give an alternative proof of Corollary ref:cor2.1.10 by letting
       \(A_1=W_x\setminus W_y\) and \(B_1=W_y\setminus W_x\) where \(W_x=A\) and \(W_y=B\)
    5. Let \(f\) be a 1:1 recursive function from \omega onto \(K_0\). Define
       \begin{equation*}
       W_{e,s}=\{x: (\exists t\le s)[f(t)=\la x,e\ra]\}
       \end{equation*}
       Show that \(\{W_{e,s}:e,s\in\omega\}\) satisfies condition
       \begin{equation*}
       (\forall s)(\exists\text{ at most one }\la e,x\ra)[x\in W_{e,s+1}-W_{e,s}]
       \end{equation*}
    #+END_exercise

    #+BEGIN_proof
    1. Prove \((x,z)\) is recursive
    3. [@3]
    4. [@4] \(W_x=\{W_{x,s}\}_{s\in\omega}\)
    #+END_proof

    #+BEGIN_exercise
    label:ex2.2.11
    Prove that there is a recursive function \(f\) s.t.
    \(\{W_{f(n)}\}_{n\in\omega}\) consists precisely of the recursive sets.
    Hence we can give an effective list of \(\Sigma_1\)-indices for the
    recursive sets but not of \(\Delta_1\)-indices
    #+END_exercise

    #+BEGIN_proof
    Obtain \(W_{f(n)}\subseteq W_n\) by enumerating \(W_n\), placing in
    \(W_{f(n)}\) only those elements enumerated in increasing order, and
    applying Exercise ref:ex2.1.19. Note that we are using the uniformity shown
    in Exercise ref:ex2.1.25
    #+END_proof

    #+BEGIN_exercise
    label:ex2.1.12
    Prove that there is a recursive function \(f(e,s)\) s.t.
    \(D_{f(e,s)}=W_{e,s}\) and hence that \(W_e=\bigcup_sD_{f(e,s)}\)
    #+END_exercise

    #+BEGIN_exercise
    label:ex2.1.13
    Prove that there are recursive functions \(f\) and \(g\) s.t.
    \(D_x\cup D_y=D_{f(x,y)}\) and \(D_x\cap D_y=D_{g(x,y)}\)
    #+END_exercise
** The Recursion Theorem
   #+ATTR_LATEX: :options [Recursion Theorem (Kleene)]
   #+BEGIN_theorem
   label:thm2.3.1
   For every recursive function \(f\) there exists an \(n\) (called a *fixed
   point* of \(f\)) s.t. \(\varphi_n=\varphi_{f(n)}\)
   #+END_theorem

   #+BEGIN_proof
   Define the recursive "diagonal" function \(d(u)\) by
   \begin{equation*}
   \varphi_{d(u)}(z)=
   \begin{cases}
   \varphi_{\varphi_u(u)}(z)&\varphi_u(u)\text{ converges}\\
   \text{undefined}&\text{otherwise}\\
   \end{cases}
   \end{equation*}
   Note that \(d\) is 1:1 and total by the \(s\)-\(m\)-\(n\) theorem. Note also
   that \(d\) is independent of \(f\).

   Given \(f\), choose an index \(v\) s.t.
   \begin{equation*}
   \varphi_v=f\circ d
   \end{equation*}
   We claim that \(n=d(v)\) is a fixed point of \(f\). First note that \(f\)
   total implies \(fd\) is total, so \(\varphi_v(v)\) converges and
   \(\varphi_{d(v)}=\varphi_{\varphi_v(v)}\). Now
   \begin{equation*}
   \varphi_n=\varphi_{d(v)}=\varphi_{\varphi_v(v)}=\varphi_{fd(v)}=\varphi_{f(n)}
   \end{equation*}
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_corollary
   label:cor2.3.2
   For every recursive function \(f\), there exists \(n\) s.t. \(W_n=W_{f(n)}\)
   #+END_corollary

   #+BEGIN_remark
   From cite:DBLP:journals/ndjfl/Owings73.

   In a typical diagonal argument there is a square array of objects
   \(\{\alpha_{x,u}\}_{x,u\in\omega}\) and one constructs a sequence
   \(D'=\{\alpha'_x\}_{x\in\omega}\) s.t. \(\alpha_x'\neq\alpha_{x,x}\), where
   \(D=\{\alpha_{x,x}\}_{x\in\omega}\) is the diagonal sequence, and hence
   \(D'\) is *not* one of the rows, \(R_u=\{\alpha_{x,u}\}_{x\in\omega}\).

   Now
   consider the matrix where \(\alpha_{x,u}=\varphi_{\varphi_u(x)}\), and where
   it is understood that \(\alpha_{x,u}\) and \(\varphi_{\varphi_u(x)}\) denote
   the totally undefined function if \(\varphi_u(x)\) diverges. Here the strong
   closure properties of the partial recursive functions under the
   \(s\)-\(m\)-\(n\) Theorem guarantee that the diagonal sequence
   \(D=\{\alpha_{x,x}\}_{x\in\omega}\) *is* one of the rows, namely the \(e\)-th
   row, \(R_e=\{\varphi_{\varphi_e(x)}\}_{x\in\omega}\), where \(\varphi_e=d\).
   Equivalently, for any \(x\), \(d(x)=\varphi_x(x)\). This is obviously computable.
   
   Now any recursive function \(f\) induces a transformation on the rows
   \(R_u=\{\varphi_{\varphi_u(x)}\}_{x\in\omega}\) of this matrix, mapping
   \(R_u\) to the row \(\{\varphi_{f\varphi_u(x)}\}_{x\in\omega}\). In
   particular, \(f\) maps the "diagonal" row
   \(R_e=\{\varphi_{d(x)}\}_{x\in\omega}\) to
   \(R_v=\{\varphi_{fd(x)}\}_{x\in\omega}\). Since \(R_e\) is the diagonal
   sequence, the \(v\)th element of the sequence, namely
   \(\varphi_{d(v)}=\varphi_{\varphi_v(v)}\), must be unchanged by this action
   of \(f\), and hence \(\varphi_{d(v)}=\varphi_{fd(v)}\)
   #+END_remark

   A typical application of the Recursion Theorem is that there exists \(n\)
   s.t. \(W_n=\{n\}\). (By the \(s\)-\(m\)-\(n\) Theorem define
   \(W_{f(x)}=\{x\}\) and by the Recursion Theorem choose \(n\) s.t.
   \(W_n=W_{f(n)}=\{n\}\))

   #+ATTR_LATEX: :options []
   #+BEGIN_proposition
   In the Recursion Theorem, \(n\) can be computed from an index for \(f\) by a
   1:1 recursive function \(g\)
   #+END_proposition

   #+BEGIN_proof
   Let \(v(x)\) be a recursive function s.t.
   \(\varphi_{v(x)}=\varphi_x\circ d\). Let \(g(x)=d(v(x))\). Both \(d\) and
   \(v\) are 1:1 by the \(s\)-\(m\)-\(n\) Theorem
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_proposition
   In the Recursion Theorem, there is an infinite r.e. set of fixed points for \(f\).
   #+END_proposition

   #+BEGIN_proof
   By the Padding Lemma ref:lemma1.3.2 there is an infinite r.e. set \(V\) of
   indices \(v\) s.t. \(\varphi_v=f\circ d\), but \(d\) is 1:1 so
   \(\{d(v)\}_{v\in V}\) in infinite and r.e.
   #+END_proof

   #+ATTR_LATEX: :options [Recursion Theorem with Parameters (Kleene)]
   #+BEGIN_theorem
   label:thm2.3.5
   If \(f(x,y)\) is a recursive function, then there is a recursive function
   \(n(y)\) s.t. \(\varphi_{n(y)}=\varphi_{f(n(y),y)}\)
   #+END_theorem

   #+BEGIN_proof
   Define a recursive function \(d\) by
   \begin{equation*}
   \varphi_{d(x,y)}(z)=
   \begin{cases}
   \varphi_{\varphi_x(x,y)}(z)&\varphi_x(x,y)\text{ converges}\\
   \text{undefined}&\text{otherwise}
   \end{cases}
   \end{equation*}
   Choose \(v\) s.t. \(\varphi_v(x,y)=f(d(x,y),y)\). Then \(n(y)=d(v,y)\) is a
   fixed point, since \(\varphi_{d(v,y)}=\varphi_{\varphi_v(v,y)}=\varphi_{f(d(v,y),y)}\)
   #+END_proof

   Informally, the Recursion Theorem allows us to define a p.r. function
   \(\varphi_n\) (or an r.e. set \(W_n\)) using its own index \(n\) in advance
   as part of the algorithm, \(\varphi_n(z):\dots n\dots\). This circularity is
   removed by the Recursion Theorem because we are really using the
   \(s\)-\(m\)-\(n\) Theorem to define a function
   \(f(x)\),\(\varphi_{f(x)}(z):\dots x\dots\) and then taking a fixed point
   \(\varphi_n(z)=\varphi_{f(n)}(z):\dots n\dots\) The only restriction on the
   informal method is that we cannot use in the program any special properties
   of \(\varphi_n\) (such as \(\varphi_n\) being total or \(W_n\neq\emptyset\)).
   For example, if for all \(x\) the function \(\varphi_{f(x)}\) being defined
   is total, then the fixed point \(\varphi_{f(x)}=\varphi_n\) will be total.
   However, the instructions for \(\varphi_{f(x)}\) must not say "wait until
   \(\varphi_{x}(z)\) converges, take the value \(v=\varphi_x(z)\) and do \(\dots\)"

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   label:thm2.3.6
   There is no r.e. function \psi s.t. if \(W_x\) is recursive then \(\psi(x)\)
   converges and \(\varphi_{\psi(x)}\) is the characteristic function for
   \(W_x\). Equivalent to Theorem ref:thm2.2.2
   #+END_theorem

   #+BEGIN_proof
   Using the Recursion Theorem define a recursive set
   \begin{equation*}
   W_n=
   \begin{cases}
   \{0\}&\psi(n)\downarrow\;\&\;
   \varphi_{\psi(n)}(0)\downarrow=0\\
   \emptyset&\text{otherwise}
   \end{cases}
   \end{equation*}
   Now \(\varphi_{\psi(n)}\) cannot be the characteristic function of \(W_n\)
   because \(0\in W_n\) iff \(\varphi_{\psi(n)}(0)=0\)
   #+END_proof

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   label:thm2.3.7
   If \(\psi(x,y)\) is a partial recursive function, then there is a recursive
   function \(n(y)\) s.t.
   \begin{equation*}
   (\forall y)[\psi(n(y),y)\downarrow\Longrightarrow\varphi_{n(y)}=\varphi_{\psi(n(y),y)}]
   \end{equation*}
   #+END_theorem

   #+BEGIN_proof
   Same as Theorem ref:thm2.3.5
   #+END_proof
*** Exercises
    #+BEGIN_exercise
    label:ex2.3.8
    A set \(A\) is *self-dual* if \(A\le_m\overbar{A}\). For example if
    \(A=B\oplus\overbar{B}\) then \(A\) is self-dual
    1. Use the Recursion Theorem to prove that no index set \(A\) can be self-dual
    2. Give a short proof of Rice's Theorem ref:cor1.4.13
    #+END_exercise

    #+BEGIN_proof
    1. Suppose \(f:A\le_m\overbar{A}\). \(f\) is recursive and there is some
       \(n\) that \(\varphi_n=\varphi_{f(n)}\). However, \(x\in A\) iff \(f(x)\in\overbar{A}\)
    2. If a recursive set is non-trivial, then it's self-dual

       \begin{equation*}
       f(x)=
       \begin{cases}
       \mu y(\chi_A(y)=0)&\chi_A(x)=1\\
       \mu y(\chi_A(y)=1)&\chi_A(x)=0
       \end{cases}
       \end{equation*}
    #+END_proof

    #+BEGIN_exercise
    label:ex2.3.9
    Show that for any p.r. function \(\psi(x,y)\) there is an \(n\) s.t. \(\varphi_n(y)=\psi(n,y)\)
    #+END_exercise

    #+BEGIN_proof
    \(\psi(n,y)=\varphi_{f(n)}(y)=\varphi_n(y)\)
    #+END_proof

    #+BEGIN_exercise
    label:ex2.3.10
    Show that Corollary ref:cor2.3.2 is equivalent to: For every r.e. set \(A\),
    \((\exists n)[W_n=\{x:\la x,n\ra\in A\}]\)
    #+END_exercise

    #+BEGIN_proof
    Suppose \(A=W_e\) and \(\varphi_{f(n)}(x)=\varphi_e(x,n)\). Hence
    there exists \(n'\) s.t. \(\varphi_{n'}(x)=\varphi_e(x,n')\)
    #+END_proof

    #+BEGIN_exercise
    label:ex2.3.11
    Use the informal technique in Theorem ref:thm2.3.6 to show that there is no
    p.r. function \(\varphi_e\) s.t. if \(\varphi_x\) is the characteristic
    function of a finite set \(F\), then \(\varphi_e(x)\downarrow=\max(F)\).
    #+END_exercise

    #+BEGIN_proof
    Define
    \begin{equation*}
    \varphi_n(t+1)=
    \begin{cases}
    1&t=(\mu s)[\varphi_{e,s}(n)\downarrow]\\
    0&\text{otherwise}
    \end{cases}
    \end{equation*}
    Note that
    \begin{equation*}
    \varphi_{e,s}(x)=y\Longrightarrow e,x,y<s
    \end{equation*}
    #+END_proof
** Complete Sets, Productive Sets and Creative Sets
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   Let \(r=1\), \(m\) or \(T\). A set \(A\) is *\(r\)-complete* if \(A\) is r.e.
   and \(W\le_r A\) for every r.e. set \(W\)
   #+END_definition

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   label:thm2.4.2
   The sets \(K,K_0,K_1\) are all 1-complete
   #+END_theorem

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. A set \(P\) is *productive* if there is a p.r. function \(\psi(x)\),
      called a *productive function* for \(P\), s.t.
      \begin{equation*}
      (\forall x)[W_x\subseteq P\Longrightarrow[\psi(x)\downarrow\;
      \&\;\psi(x)\in P-W_x]]
      \end{equation*}
   2. An r.e. set \(C\) is *creative* if \(\overbar{C}\) is productive
   #+END_definition

   For example, the set \(K\) is creative since \(\overbar{K}\) is productive
   via the identity function \(\psi(x)=x\). Since \(K\equiv K_0\equiv K_1\), we
   know that \(K_0\) and \(K_1\) are also creative

   A creative set \(C\) is "effectively nonrecursive" in the sense that for any
   candidate \(W_x\) for \(\overbar{C}\), \(\psi(x)\) is an effective
   counterexample; namely \(\psi(x)\in\overbar{C}-W_x\)

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   Any productive set \(P\) has a 1:1 total recursive productive function \(p\)
   #+END_theorem

   #+BEGIN_proof
   Let \(P\) be productive via \psi. First obtain a *total* productive function
   \(q\) for \(P\) as follows. Define a recursive function \(g\) s.t.
   \begin{equation*}
   W_{g(x)}=
   \begin{cases}
   W_x&\psi(x)\downarrow\\
   \emptyset&\text{otherwise}
   \end{cases}
   \end{equation*}
   Define \(q(x)\) to be either \(\psi(x)\) or \(\psi(g(x))\), whichever
   converges first. Now if \(W_x\subseteq P\), then \(\psi(x)\) converges and
   \(W_{g(x)}=W_x\) so both \(\psi(g(x))\) and \(\psi(x)\) are in \(P-W_x\).

   Now convert \(q\) to a 1:1 productive function \(p\). Let
   \(W_{h(x)}=W_x\cup\{q(x)\}\). Note that
   \begin{equation*}
   W_x\subseteq P\Longrightarrow W_{h(x)}\subseteq P
   \end{equation*}
   Define \(p(0)=q(0)\). To compute \(p(x+1)\), enumerate the set
   \(\{q(x+1),qh(x+1),qh^2(x+1),\dots\}\) until either: some \(y\) not in
   \(\{p(0),\dots,p(x)\}\) is found; or a repetition occurs. In the former case,
   set \(p(x+1)=y\). In the latter case, \(W_{x+1}\subsetneq P\), and we can set
   \(p(x+1)=(\mu y)[y\not\in\{p(0),\dots,p(x)\}]\)
   #+END_proof




* Reference
  bibliographystyle:alpha
  bibliography:/media/wu/file/stuuudy/notes/references.bib
