% Created 2020-06-22 一 23:27
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\input{../preamble.tex}
%\\tf{\([^\}]*\)} \*\1\*
\author{Robert I. Soare}
\date{\today}
\title{Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets}
\hypersetup{
 pdfauthor={Robert I. Soare},
 pdftitle={Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents \clearpage\section{Recursive Functions}
\label{sec:org5c66b6c}
\subsection{Formal Definitions of Computable Functions \label{sec-1.2}}
\label{sec:org1ca4e92}
\subsubsection{Primitive Recursive Functions}
\label{sec:org2ac0043}
\begin{definition}[]
The class of primitive recursive functions is the smallest class \(\calc\) of
functions closed under the following schema
\begin{enumerate}
\item the \textbf{successor function}, \(\lambda x[x+1]\in\calc\)
\item the \textbf{constant functions}, \(\lambda x_1\dots x_n[m]\in\calc\), \(0\le n,m\)
\item the \textbf{identity function}, \(\lambda x_1\dots x_n[x_i]\in\calc\), \(1\le
      i\le n\)
\item (Composition) If \(g_1,\dots,g_m,h\in\calc\), then
\begin{equation*}
f(x_1,\dots,x_n)=h(g_1(x_1,\dots,x_n),\dots,g_m(x_1,\dots,x_n))
\end{equation*}
is in \(\calc\) where \(g_1,\dots,g_m\) are functions of \(n\) variables and \(h\)
is a function of \(m\) variables
\item (Primitive Recursion) If \(g,h\in\calc\) and \(n\ge 1\) then \(f\in\calc\) where
\begin{gather*}
f(0,x_2,\dots,x_n)=g(x_2,\dots,x_n)\\
f(x_1+1,x_2,\dots,x_n)=h(x_1,f(x_1,\dots,x_n),x_2,\dots,x_n)\\
\end{gather*}
\end{enumerate}
\end{definition}


Hence a function is primitve recursive if there is a \textbf{derivation}, namely
a sequence \(f_1,\dots,f_k=f\) s.t. for each \(f_i,i\le k\) is either an initial
function or obtained from 4 or 5.

A predicate (relation) is \textbf{primitive recursive} if its characteristic
function is.
\subsubsection{Diagonalization and Partial Recursive Functions}
\label{sec:orgf2ecdcf}
Although the primitive recursive functions include all the usual functions
from elementary number theory they fail to include \textbf{all} computable
functions. Each derivation of a primitive recursive function is a finite
string of symbols from a fixed finite alphabet, and thus all derivations can
be effectively listed. Let \(f_n\) be the function corresponding to the \(n\)th
derivation in this listing. Then the function \(g(x)=f_x(x)+1\) cannot be
primitive recursive.

The same argument applies to any effective set of schemata which produces
only \textbf{total} functions. \emph{Thus to obtain all computable functions we are}
\emph{forced to consider computable \textbf{partial} functions.}

\index{ partial recursive} \index{ p.r.}
\begin{definition}[Kleene]
\label{def2.2}
The class of \textbf{partial recursive} (p.r.) functions is the least class
obtained by closing under schemata 1 through 5 for the primitive recursive
functions and the following schemata 6. A \textbf{total recursive} function
(abbreviated \textbf{recursive} function) is a partial recursive function which
is total.
\begin{enumerate}
\setcounter{enumi}{5}
\item (Unbounded Search) If \(\theta(x_1,\dots,x_n,y)\) is a partial
recursive function of \(n+1\) variables, and 
\begin{align*}
\psi(x_1,\dots,x_n)=\mu y[\theta&(x_1,\dots,x_n,y)\downarrow=0\\
&\wedge (\forall z\le y)[\theta(x_1,\dots,x_n,z)\downarrow]]
\end{align*}
\end{enumerate}
\end{definition}
\begin{definition}[]
A relation \(R\subseteq \omega^n,n\ge 1\) is \textbf{recursive} (\textbf{primitive
recursive}, has property \(P\)) if its characteristic function \(\chi_R\) is
recursive (primitive recursive) where \(\chi_R(x_1\dots,x_n)=1\) if and only if
\((x_1,\dots,x_n)\in R\).
\end{definition}
\subsubsection{Turing Computable Functions}
\label{sec:org0944f35}
A \textbf{Turing machine} \(M\) includes a two-way infinite \textbf{tape} divided into
\textbf{cells}, a \textbf{reading head} which scans one cell of the tape at a time,
and a finite set of internal \textbf{states} \(Q=\{q_0,\dots,q_n\},n\ge 1\). Each
cell is either blank (B) or has written on it the symbol 1. In a single step
the machine may simultaneously
\begin{enumerate}
\item change from one state to another
\item change the scanned symbol \(s\) to another symbol \(s'\in S=\{1,B\}\)
\item move the reading head one cell to the right (R) or left (L)
\end{enumerate}


The operation of \(M\) is controlled by a partial map 
\(\delta:Q\times S\to Q\times S\times\{R,L\}\)

The map \(\delta\) viewed as a finite set of quintuples is called a \textbf{Turing
program}. The \textbf{input} integer \(x\) is represented by a string of \(x+1\)
consecutive 1's.
\subsubsection{Exercises}
\label{sec:org65646a4}
\begin{exercise}[Definition by cases]
\label{ex2.6}
If \(g_1(x),\dots,g_n(x)\) are primitive recursive functions and
\(R_1(x),\dots,R_n(x)\) are primitive recursive relations which are mutually
exclusive and exhaustive show that \(f\) is primitive where \(f(x)=g_1(x)\)
if \(R_1(x)\),\(\dots\),\(f(x)=g_n(x)\) if \(R_n(x)\)
\end{exercise}

\begin{proof}
\(f(x)=\sum_{i=1}^n\chi_{R_i}(x)\times g_i(x)\)
\end{proof}
\subsection{The Basic Results}
\label{sec:org8acc580}
\textbf{Church's Thesis} asserts that these functions coincide with the
intuitively computable functions. We shall accept Church's Thesis and from
now on shall use the terms \emph{``partial recursive''} \emph{``Turing computable''} and
\emph{``computable''} interchangeably

\begin{definition}[]
Let \(P_e\) be the Turing program with code number (Gödel number) \(e\) 
(also called \textbf{index} \(e\)) in this
listing and let \(\varphi_e^{(n)}\) be the partial fucntions of \(n\) variables
computed by \(P_e\), where \(\varphi_e\) abbreviates \(\varphi_e^{(1)}\)
\end{definition}

\begin{lemma}[Padding Lemma]
\label{lemma1.3.2}
Each partial recursive function \(\varphi_x\) has \(\aleph_0\) indices, and
furthermore for each \(x\) we can effectively find an infinite set \(A_x\) of
indices for the same partial function
\end{lemma}


\begin{proof}
For any program \(P_x\) mentioning internal states \(\{q_0,\dots,q_n\}\) add
extraneous instructions \(q_{n+1}Bq_{n+1}BR,q_{n+2}Bq_{n+2},BR,\dots\) to get
new programs for the same functions
\end{proof}
\begin{theorem}[Normal Form Theorem (Kleene]
\label{thm1.3.3}
There exist a predicate \(T(e,x,y)\) (called the \textbf{Kleene T-predicate}) and a
function \(U(y)\) which are recursive (indeed primitive recursive) s.t.
\begin{equation*}
\varphi_e(x)=U(\mu y T(e,x,y))
\end{equation*}
\end{theorem}

\begin{proof}
Informally, the predicate \(T(e,x,y)\) asserts that \(y\) is the code number
of some Turing computation according to program \(P_e\) with input \(x\). To
see whether \(T(e,x,y)\) holds we first effectively recover from \(e\) the
Program \(P_e\); then recover from \(y\) the computation
\(c_0,c_1,\dots,c_n\) if \(y\) codes such a computation. Now check whether
\(c_0,\dots,c_n\) is a computation according to \(P_e\) with \(x\) as the
input in \(c_0\). If so \(U(y)\) simply outputs the number of \(1\)'s in the
final configuration \(c_n\).
\end{proof}

It follows from the Normal Form Theorem that every Turing computable partial
function is partial recursive. To prove the converse one constructs Turing
machines corresponding to the schemata \((1)\to(6)\).

Note by Theorem \ref{thm3.3} it follows that every partial recursive function
can be obtained from two primitive recursive functions by \textbf{one} application
of the \(\mu\)-operator

\begin{theorem}[Enumeration Theorem]
\label{thm3.4}
There is a p.r. function of 2 variables \(\varphi_z^{(2)}(e,x)\) s.t.
\(\varphi_z^{(2)}(e,x)=\varphi_e(x)\). Indeed the Enumeration Theorem holds for
p.r. functions of \(n\) variables
\end{theorem}
\begin{proof}
Let \(\varphi_z^{(2)}(e,x)=U(\mu y T(e,x,y))\). For
\(\varphi_z^{(n)}(e,x_1,\dots,x_{n-1})\), by \(s\)-\(m\)-\(n\) theorem, 
\begin{equation*}
\varphi_z^{(n)}(e,\bar{x})=
\varphi_{s^2_{n-1}(z,e)}^{(n-1)}(\bar{x})
\end{equation*}
Thus we only need to make sure that \(s^2_{n-1}(z,e)\in A_e\), which can be
effectively found.
\end{proof}
\begin{theorem}[Parameter Theorem ($s$-$m$-$n$ Theorem)]
For every \(m,n\ge 1\) there exists a 1:1 recursive function \(s^m_n\) of \(m+1\)
variables s.t. for all \(x,y_1,y_2,\dots,y_m\)
\begin{equation*}
\varphi_{s^m_n(x,y_1,\dots,y_m)}^{(n)}=\lambda z_1,\dots,z_n
(\varphi_x^{(m+n)}(y_1,\dots,y_m,z_1,\dots,z_n))
\end{equation*}
\end{theorem}
\begin{proof}
\emph{(informal)}. For simplicity consider the case \(m=n=1\).
\(\varphi^{(1)}_{s^1_1(x,y)}=\lambda z(\varphi_x^{(2)}(y,z))\)
The program
\(P_{s_1^1(x,y)}\) on input \(z\) first obtains \(P_x\) and then applies \(P_x\) to
input \((y,z)\). Now \(s=s_1^1\) is a recursive function by Church's Thesis
since this is an effective procedure in \(x\) and \(y\). If \(s\) is not
already 1:1 it may be replaced by a 1:1 recursive function \(s'\) s.t.
\(\varphi_{s(x,y)}=\varphi_{s'(x,y)}\) by sing the padding lemma, and by
defining \(s'(x,y)\) in increasing order of \(\la x,y\ra\), where
\(\la x,y\ra\) is the image of \((x,y)\) under the pairing function
\end{proof}

\begin{remark}
Here is an interesting question in \href{https://cs.stackexchange.com/questions/80837/is-smn-theorem-the-same-concept-as-currying}{StackExchange}
\end{remark}

The \(s\)-\(m\)-\(n\) theorem asserts that \(y\) may be treated as a fixed parameter
in the program \(P_{s(x,y)}\) which operate on \(z\) and furthermore that the
index \(s(x,y)\) of this program is effective in \(x\) and \(y\). A simple
application of the \(s\)-\(m\)-\(n\) theorem is the existence of a recursive
function \(f(x)\) s.t. \(\varphi_{f(x)}=2\varphi_x\). Let
\(\psi(x,y)=2\varphi_x(y)\). By Church's Thesis
\(\psi(x,y)=\varphi_e^{(2)}(x,y)\) for some \(e\). Let \(f(x)=s^1_1(e,x)\)

We let \(\la x,y\ra\) denote the image of \((x,y)\) under the standard pairing
function \(\frac{1}{2}(x^2+2xy+y^2+3x+y)\) which is a bijective recursive
function from \(\omega^2\to\omega\). Let \(\pi_1\) and \(\pi_2\) denote the inverse
functions \(\pi_1(\la x,y\ra)=x\)

For a relation \(R\subseteq\omega^n\), \(n>1\), we say that \(R\) has some
property \(P\) iff the set \(\{\la x_1,\dots,x_n\ra:R(x_1,\dots,x_n)\}\) has
property \(P\)

\begin{definition}[]
We write \(\varphi_{e,s}(x)=y\) if \(x,y,e<s\) and \(y\) is the output
\(\varphi_e(x)\) in \(<s\) steps of the Turing machine \(P_e\). If such a \(s\)
exists we say \(\varphi_{e,s}(x)\) \textbf{converges}, which we write as
\(\varphi_{e,s}(x)\downarrow\), and \textbf{diverges} (\(\varphi_{e,s}(x)\uparrow\)).
Similarly, we write \(\varphi_e(x)\downarrow\) if \(\varphi_{e,s}(x)\downarrow\)
for some \(s\)
\end{definition}

\begin{theorem}[]
\label{thm1.3.9}
\begin{enumerate}
\item The set \(\{\la e,x,s\ra:\varphi_{e,s}(x)\downarrow\}\) is recursive
\item The set \(\{\la e,x,y,s\ra:\varphi_{e,s}(x)=y\}\) is recursive
\end{enumerate}
\end{theorem}
\begin{proof}
From Church's Thesis since they are all computable
\end{proof}
\subsubsection{Exercises}
\label{sec:org3f4312e}
\begin{exercise}
\label{ex1.3.11}
Prove the following alternative definition of \(\varphi_{e,s}(x)=y\) also
satisfies Theorem \ref{thm1.3.9} as well as the convenient properties:
\begin{equation*}
\varphi_{e,s}(x)=y\Longrightarrow e,x,y<s
\end{equation*}
and
\begin{equation*}
(\forall s)(\exists\text{ at most one }\la e,x,y\ra)[\varphi_{e,s}(x)=y\;\&\;
\varphi_{e,s-1}(x)\uparrow]
\end{equation*}
and hence
\begin{equation*}
(\forall s)(\exists \text{ at most one }\la e,x\ra)
[x\in W_{e,s+1}-W_{e,s}]
\end{equation*}

Define \(\varphi_{e,s}(x)=y\) by recursion on \(s\) on follows. Let
\(\varphi_{e,0}(x)\uparrow\) for all \(x\). Let \(\varphi_{e,s+1}(x)=y\) iff
\(\varphi_{e,s}(x)=y\), or \(s=\la e,x,y,t\ra\) for some \(t>0\) and \(y\)
is the output of \(\varphi_{e}(x)\) in \(\le t\) steps of the Turing program \(P_e\)
\end{exercise}
\subsection{Recursively Enumerable Sets and Unsolvable Problems}
\label{sec:org256855d}
\index{ recursively enumerable}
\index{ r.e.}
\begin{definition}[]
\begin{enumerate}
\item A set \(A\) is \textbf{recursively enumerable} (r.e.) if \(A\) is the domain of
some p.r. function
\item let the \(e\)th r.e. set be denoted by
\begin{equation*}
W_e=\dom(\varphi_e)=\{x:\varphi_e(x)\downarrow\}=\{x:(\exists y)T(e,x,y)\}
\end{equation*}
\item \(W_{e,s}=\dom(\varphi_{e,s})\)
\end{enumerate}
\end{definition}

Note that \(\varphi_e(x)=x\) iff \((\exists s)[\varphi_{e,s}=y]\) and 
\(x\in W_e\) iff \((\exists s)(x\in W_{e,s})\)

\begin{definition}[]
Let \(K=\{x:\varphi_x(x)\text{ converges }\}=\{x:x\in W_x\}\)
\end{definition}
\begin{proposition}[]
\(K\) is r.e.
\end{proposition}
\begin{proof}
\(K\) is the domain of the following p.r. function
\begin{equation*}
\psi(x)=
\begin{cases}
x&\text{if } \varphi_x(x)\text{ converges},\\
\text{undefined}&\text{otherwise}
\end{cases}
\end{equation*}
Now \(\psi\) is p.r. by Church's Thesis since \emph{\(\psi(x)\) can be computed by}
\emph{applying program \(P_x\) to input \(x\) and giving output \(x\) only if}
\emph{\(\varphi(x)\) converges}. Alternatively and more formally,
\(K=\dom(\theta)\) where \(\theta(x)=\varphi_z^{(2)}(x,x)\) for \(\varphi_z^{(2)}\)
the p.r. function defined in the Enumeration Theorem \ref{thm3.4}
\end{proof}
\begin{corollary}[]
\label{col1}
\(K\) is not recursive
\end{corollary}
\begin{proof}
If \(K\) had a recursive characteristic function \(\chi_K\) then the following
function would be recursive
\begin{equation*}
f(x)=
\begin{cases}
\varphi_x(x)+1&\text{if }x\in K\\
0&\text{if }x\not\in K
\end{cases}
\end{equation*}
However \(f\) cannot be recursive since \(f\neq\varphi_x\) for any \(x\)
\end{proof}
\begin{definition}[]
\(K_0=\{\la x,y\ra:x\in W_y\}\)
\end{definition}
\(K_0\) is p.r. \(K_0=\dom\theta_0\), where
\(\theta(\la x,y\ra)=\varphi^{(2)}_z(y,x)\)

\begin{corollary}[]
\label{cor4.6}
\(K_0\) is not recursive
\end{corollary}
\begin{proof}
\(x\in K\) iff \(\la x,x\ra\in K_0\)
\end{proof}

The \textbf{halting problem} is to decide for arbitrary \(x\) and \(y\) whether
\(\varphi_x(y)\downarrow\). Corollary \ref{cor4.6} asserts the unsolvability of the
halting problem.

\begin{definition}[]
\begin{enumerate}
\item \(A\) is a \textbf{many-one reducible} (\textbf{\(m\)-reducible}) to \(B\) (written
\(A\le_m B\)) if there is a recursive function \(f\) s.t. \(f(A)\subseteq B\) and
\(f(\bar{A})\subseteq\bar{B}\), i.e. \(x\in A\) iff \(f(x)\in B\)
\item \(A\) is \textbf{one-one reducible} (\textbf{1-reducible}) to \(B\) (\(A\le_1 B\)) if
\(A\le_m B\) by a 1:1 recursive function
\end{enumerate}
\end{definition}

The proof of corollary \ref{cor4.6} established that \(K\le_1 K_0\) via the
function \(f(x)=\la x,x\ra\)
\begin{definition}[]
\begin{enumerate}
\item \(A\equiv_m B\) if \(A\le_m B\) and \(B\le_m A\)
\item \(A\equiv_1 B\) if \(A\le_1 B\) and \(B\le_1 A\)
\item \(\deg_m(A)=\{B:A\equiv_m B\}\)
\item \(\deg_1(A)=\{B:A\equiv_1 B\}\)
\end{enumerate}
\end{definition}

The equivalence classes under \(\equiv_m\) and \(\equiv_1\) are called the
\textbf{m-degrees} and \textbf{1-degrees} respectively

\begin{proposition}[]
If \(A\le_m B\) and \(B\) is recursive then \(A\) is recursive
\end{proposition}

\begin{proof}
\(\chi_A(x)=\chi_B(f(x))\)
\end{proof}

\begin{theorem}[]
\label{thm4.10}
\(K\le_1\text{Tot}:=\{x:\varphi_x\text{ is a total function}\}\)
\end{theorem}
\begin{proof}
Define the function
\begin{equation*}
\psi(x,y)=
\begin{cases}
1&\text{if } x\in K\\
\text{undefined} &\text{otherwise}
\end{cases}
\end{equation*}
By \(s\)-\(m\)-\(n\) theorem, there is a 1:1 recursive function \(f\) s.t.
\(\varphi_{f(x)}(y)=\psi(x,y)\). Choose \(e\) s.t. \(\varphi_e(x,y)=\psi(x,y)\) 
since \(\psi\) is p.r. and
define \(f(x)=s_1^1(e,x)\). Note that
\begin{align*}
&x\in K\Longrightarrow \varphi_{f(x)}=\lambda y[1]\Longrightarrow\varphi_{f(x)}\text{ total}
\Longrightarrow f(x)\in\text{Tot}\\
&x\not\in K\Longrightarrow\varphi_{f(x)}=\lambda y[\text{undefined}]\Longrightarrow
\varphi_{f(x)}\text{ not total}\Longrightarrow f(x)\not\in\text{Tot}
\end{align*}
\end{proof}

\begin{definition}[]
A set \(A\subseteq\omega\) is an \textbf{index set} if for all \(x\) and \(y\)
\begin{equation*}
(x\in A\wedge\varphi_x=\varphi_y)\Longrightarrow y\in  A
\end{equation*}
\end{definition}

\begin{theorem}[]
If \(A\) is a nontrivial index set, i.e., \(A\neq \emptyset,\omega\), then either
\(K\le_1 A\) or \(K\le_1\overline{A}\)
\end{theorem}

\begin{proof}
Choose \(e_0\) s.t. \(\varphi_{e_0}(y)\) is undefined for all \(y\). If
\(e_0\in\overline{A}\), then \(K\le_1 A\) as follows. Since \(A\neq\emptyset\) we can
choose \(e_1\in A\). Now \(\varphi_{e_1}\neq\varphi_{e_0}\) because \(A\) is an
index set. By \(s\)-\(m\)-\(n\) theorem define a 1:1 recursive function \(f\)
s.t.
\begin{equation*}
\varphi_{f(x)}(y)=
\begin{cases}
\varphi_{e_1}(y)&x\in K\\
\text{undefined}&x\not\in K
\end{cases}
\end{equation*}
Now
\begin{align*}
&x\in K\Longrightarrow\varphi_{f(x)}=\varphi_{e_1}\Longrightarrow f(x)\in A\\
&x\not\in K\Longrightarrow\varphi_{f(x)}=\varphi_{e_0}\Longrightarrow
f(x)\in\overline{A}
\end{align*}
\end{proof}

It's possible that both \(K\le_1 A\) and \(K\le_1\overline{A}\) for an index set
\(A\), for example if \(A=\text{Tot}\)
\begin{corollary}[Rice's Theorem]
\label{cor1.4.13}
Let \(\calc\) be any class of partial recursive functions. Then
\(\{n:\varphi_n\in\calc\}\) is recursive iff \(\calc=\emptyset\) or \(\calc\) is
the set of all partial recursive functions
\end{corollary}
\begin{proof}
\(\calc\) is an index set and hence is trivial.
\end{proof}
\begin{definition}[]
\begin{align*}
&K_1=\{x:W_x\neq\emptyset\}\\
&\text{Fin}=\{x:W_x\text{ is finite}\}\\
&\text{Inf}=\omega-\text{Fin}=\{x:W_x\text{ is infinite}\}\\
&\text{Tot}=\{x:\varphi_x\text{ is total}\}=\{x:W_x=\omega\}\\
&\text{Con}=\{x:\varphi_x\text{ is total and constant}\}\\
&\text{Cof}=\{x:W_x\text{ is cofinite}\}\\
&\text{Rec}=\{x:W_x\text{ is recursive}\}\\
&\text{Ext}=\{x:\varphi_x\text{ is extendible to a total recursive function}\}\\
\end{align*}
\end{definition}
\begin{definition}[]
An r.e. set \(A\) is \textbf{1-complete} if \(W_e\le_1 A\) for every r.e. set \(W_e\)
\end{definition}

\(K_0\) is 1-complete because \(x\in W_e\) iff \(\la x,e\ra\in K_0\)

\begin{definition}[]
Let \(A\) \textbf{join} \(B\) written \(A\oplus B\) be
\begin{equation*}
\{2x:x\in A\}\cup\{2x+1:x\in B\}
\end{equation*}
\end{definition}
\subsubsection{Exercises}
\label{sec:orge0758a4}
\begin{exercise}
\label{4.17}
\begin{enumerate}
\item \(A\le_m A\oplus B\) and \(B\le_m A\oplus B\)
\item if \(A\le_m C\) and \(B\le_m C\) then \(A\oplus B\le_m C\)
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item 

\item Easy
\end{enumerate}
\end{proof}

\begin{exercise}
\label{ex4.18}
\(K\equiv_1 K_0\equiv_1 K_1\)
\end{exercise}
\begin{proof}
\(K\le_1 A\) for \(A=K_1,\text{con}\) or
\(\text{Inf}\).

\(K_0\le K\) for the same reason.

For \(K\le K_1\)
\begin{equation*}
\varphi_{f(x)}(y)=
\begin{cases}
x&x\in K\\
\text{undefined}&x\not\in K
\end{cases}
\end{equation*}

For \(K_0\le_1 K\), the same (find a \(x\) s.t. \(x\in W_x\))

Also note that \(K\) and \(K_1\) are 1-complete
\end{proof}

\begin{exercise}
\label{ex4.19}
Prove directly (without Rice's theorem) that \(K\le_1\text{Fin}\)
\end{exercise}
\begin{proof}
Let
\begin{equation*}
\varphi_{f(x)}(s)=
\begin{cases}
0&x\not\in K_s\\
\text{undefined}&x\in K_s
\end{cases}
\end{equation*}
where \(K_s=W_{e,s}\) for some \(e\) s.t. \(K=W_e\). If \(x\in K\), then
\(\dom(\varphi_{f(x)})\) is finite
\end{proof}
\begin{exercise}
For any \(x\) show that \(\overline{K}\le_1\{y:\varphi_x=\varphi_y\}\) and
\(\overline{K}\le_1\{y:W_x=W_y\}\)
\end{exercise}
\begin{proof}
Use the method of exercise \ref{ex4.19}. If \(x\not\in W_x\), then
\(\dom(\varphi_{f(x)})=\omega\).
\end{proof}
\begin{exercise}
\(\text{Ext}\neq\omega\)
\end{exercise}
\begin{proof}
Use \(K\). If \(\psi(x)\) can be extended to a recursive function, then \(K\) would
be recursive.
\end{proof}

\begin{exercise}
\label{ex1.4.22}
\begin{enumerate}
\item Disjoints sets \(A\) and \(B\) are \textbf{recursively inseparable} if there is no
recursive set \(C\) s.t. \(A\subseteq C\) and \(C\cap B=\emptyset\). Show that
there exists disjoint r.e. sets which are recursively inseparable.
\item Give an alternative proof that \(\text{Ext}\neq\omega\)
\item For \(A\) and \(B\) as in part 1, prove that \(K\equiv_1 A\) and \(K\equiv_1 B\)
\end{enumerate}
\end{exercise}
\begin{proof}
\begin{enumerate}
\item Consider \(A=\{x:\varphi_x(0)=0\}\) and \(B=\{x:\varphi_x(0)=1\}\).
\item corollary from 1.
\item 
\end{enumerate}
\end{proof}

\begin{exercise}
A set \(A\) is \textbf{cylinder} if \((\forall B)[B\le_m A\Longrightarrow B\le_1 A]\)
\begin{enumerate}
\item Show that any index set is a cylinder
\item Show that any set of the form \(A\times\omega\) is a cylinder
\item Show that \(A\) is a cylinder iff \(A\equiv_1 B\times\omega\) for some set \(B\)
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item If different \(x,y\in B\) and \(f(x)=f(y)\), we could just add redundent
computation and \(\varphi_{f(x)}=\varphi_{f(y)}\)
\item to make sure images are different by \(\omega\)
\item 
\end{enumerate}
\end{proof}

\begin{exercise}
Show that the partial recursive functions are not closed under \(\mu\), i.e.,
there is a p.r. function \(\psi\) s.t. \(\lambda x[\mu y[\psi(x,y)=0]]\) is not p.r.
\end{exercise}
\begin{proof}
\(\psi(x,y)=0\) if \(y=1\) or \(y=0\) and \(\varphi_x(x)\downarrow\).
\end{proof}
\begin{exercise}
If \(A\) is recursive and \(B,\overline{B}\) are each \(\neq\emptyset\), then
\(A\le_m B\)
\end{exercise}
\begin{proof}
choose elements \(b\in B\) and \(b'\in\overline{B}\). Then
\begin{equation*}
\psi_{f(x)}(s)=
\begin{cases}
b&x\in A\\
b'&x\not\in A\\
\end{cases}
\end{equation*}
\end{proof}
\begin{exercise}
Prove that \(\text{Inf}\equiv_1\text{Tot}\equiv_1\text{Con}\)
\end{exercise}
\begin{proof}
\(\text{Tot}\equiv_1\text{Con}\) is obvious. For \(\text{Inf}\le_1\text{Con}\),
define
\begin{equation*}
\psi(e,x)=
\begin{cases}
0&\text{if }(\exists y>x)[\varphi_e(y)\downarrow]\\
\uparrow&\text{otherwise}
\end{cases}
\end{equation*}
\end{proof}

\begin{exercise}
\(\text{Fin}\le_1\text{Cof}\)
\end{exercise}
\begin{proof}
\begin{equation*}
\varphi_{f(e)}(s)=
\begin{cases}
\uparrow&\text{if } W_{e,s+1}-W_{e,s}\neq\emptyset\\
0&\text{otherwise}
\end{cases}
\end{equation*}
\end{proof}

\subsection{Recursive Permutation and Myhill's Isomorphism Theorem}
\label{sec:org5de4f6a}
\begin{definition}[]
\begin{enumerate}
\item A \textbf{recursive permutation} is a 1:1, recursive function from \(\omega\) to \(\omega\)
\item A property of set is \textbf{recursively invariant} if it's invariant under all
recursive permutation
\end{enumerate}
\end{definition}
Examples:
\begin{enumerate}
\item \(A\) is r.e. (\(A\le_1\im(A)\))
\item \(A\) has cardinality n
\item \(A\) is recursive
\end{enumerate}


Properties that not recursively invariant:
\begin{enumerate}
\item \(2\in A\)
\item \(A\) contains the even integers
\item \(A\) is an index set
\end{enumerate}


\begin{definition}[]
A is \textbf{recursively isomorphic} to \(B\) (written \(A\equiv B\)) if there is a
recursive permutation \(p\) s.t. \(p(A)=B\)
\end{definition}

\begin{definition}[]
The equivalence classes under \(\equiv\) are called \textbf{recursive isomorphism types}
\end{definition}

\begin{theorem}[Myhill Isomorphism Theorem]
\label{thm5.4}
\(A\equiv B\Longleftrightarrow A\equiv_1 B\)
\end{theorem}
\begin{proof}
(\(\Longrightarrow\)) trivial.

(\(\Longleftarrow\)) Let \(A\le_1 B\) via \(f\) and \(B\le_1 A\) via \(g\). We define a
recursive permutation \(h\) by stages so that \(h(A)=B\). We let
\(h=\bigcup_sh_s\), where \(h_0=\emptyset\) and \(h_s\) is that portion of \(h\)
defined by the end of stage \(s\). Assume \(h_s\) is given so that in particular
we can effectively check for membership in \(\dom{h_s}\) and \(\ran(h_s)\) which
we both assume finite

\emph{Stage} \(s+1=2x+1\). Assume that \(h_s\) is \(1:1\), \(\dom{h_s}\) is finite and \(y\in
   A\) iff \(h_s(y)\in B\) for all \(y\in\dom{h_s}\).If \(h_s(x)\) is defined, do
nothing. Otherwise enumerate the set
\(\{f(x),f(h_s^{-1}f(x)),\dots,f(h_s^{-1}f)^n(x),\dots\}\) until the fist
element \(y\) not yet in \(\ran(h_s)\). Define \(h_{s+1}(x)=y\). \(y\) must exist
since \(f\) and \(h_s\) are \(1:1\) and \(x\not\in\dom{h_s}\)

\emph{Stage} \(s+1=2x+2\). Define \(h^{-1}(x)\) similarly with \(f,h_s,\dom\) and
\(\ran\) replaced by \(g,h_s^{-1},\ran,\dom\) respectively
\end{proof}

\begin{definition}[]
A function \(f\) \textbf{dominates} a function \(g\) if \(f(x)\ge g(x)\) for almost every
(all but finitely many) \(x\in\omega\)
\end{definition}

\subsubsection{Exercises}
\label{sec:org1a4a001}
\begin{exercise}[$\times$]
Prove that the primitive recursive permutations do not form a group under composition
\end{exercise}
\begin{proof}
Define \(g(x)=\mu yT(e,x,y)\). \(g\) dominates all primitive recursive functions
since \(y\ge U(y)\) for all \(y\). Suppose \(f\) is a primitive recursive
permutation and \(f(g(x))=x\) if \(x\) is even. Note that given \(y\) we can
primitively recursively compute whether there is an \(x\) s.t. \(g(x)=y\)
\end{proof}

\begin{exercise}
\label{ex1.5.8}
Let \(\omega=\bigcup_nA_n=\bigcup_nB_n\) where the sequences
\(\{A_n\}_{n\in\omega}\) and \(\{B_n\}_{n\in\omega}\) are each pairwise disjoint.
Let \(f\) and \(g\) be 1:1 recursive functions s.t. \(f(A_n)\subseteq B_n\) and
\(g(B_n)\subseteq A_n\) for all \(n\). Show that the construction of Theorem
\ref{thm5.4} produces a recursive permutation \(h\) s.t. \(h(A_n)=B_n\) for all \(n\)
\end{exercise}

\begin{proof}
\emph{stage} \(s+1=2x+1\): assume \(h_s\) is 1:1, \(\dom h_s\) is finite. Hence
there is \(a\in\omega\) not in \(\dom h_s\). Then by\ldots{}
\end{proof}

\begin{exercise}[Rogers]
\label{ex1.5.9}
Let \(\calp\) be the class of partial recursive functions of one variable. A
\textbf{numbering} of the p.r. function is a map \(\pi\) from \(\omega\) onto \(\calp\). The
numbering \(\{\varphi_e\}_{e\in\omega}\) is called the \textbf{standard numbering}.
Let \(\hat{\pi}\) be another numbering and let \(\psi_e\) denote
\(\hat{\pi}(e)\). Then \(\hat{\pi}\) is an \textbf{acceptable} numbering if there
are recursive functions \(f\) and \(g\) s.t.
\begin{enumerate}
\item \(\varphi_{f(x)}=\psi_x\)
\item \(\psi_{g(x)}=\varphi_x\)
\end{enumerate}


Show that for any acceptable numbering \(\hat{\pi}\), there is a recursive
permutation \(p\) of \(\omega\) s.t. \(\varphi_x=\psi_{p(x)}\) for all \(x\)
\end{exercise}

\begin{proof}
Define \(e_1\sim e_2\) if \(\varphi_{e_1}\) and \(\varphi_{e_2}\) computes
the same p.r. function. Then we get an enumeration
\(([e_i])_{i\in\omega}=A/\sim\). Define \(A_i=[e_i]\). Obviously
\(f(A_i)\subseteq B_i\) and vice versa

By exercise \ref{ex1.5.8} with appropriate definitions of \(A_n\) and \(B_n\)
it suffices to convert \(f\) and \(g\) to a 1:1 recursive functions \(f_1\)
and \(g_1\) satisfying (1) and (2).

To define \(f_1\) from \(f\) use the Padding Lemma \ref{lemma1.3.2}. To define
\(g_1(x)\) we must be able (uniformly in \(x\))  to effectively generate an
infinite set \(S_x\) of indices s.t. for each \(y\in S_x\)
\(\psi_y=\psi_{g(x)}\). Take any two recursively inseparable r.e. sets \(A\)
and \(B\), such as those of Exercise \ref{ex1.4.22}, and define
\begin{equation*}
\varphi_{k(x,y)}(z)=
\begin{cases}
\varphi_x(z)&y\in A\\
0&y\in B\\
\text{undefined}&\text{otherwise}
\end{cases}
\end{equation*}
and similarly \(\varphi_{l(x,y)}\) with 1 in place of 0. Let
\(C_x=\{k(x,y):y\in A\}\) and \(D_x=\{l(x,y):y\in A\}\). If
\(\varphi_x\neq\lambda z[0]\), then \(g(C_x)\) cannot be finite or else \(A\)
and \(B\) are recursively separable. Hence \(S_x=g(C_x)\cup g(D_x)\) is
infinite. Note we do not have to know this in order to see that \(S_x\) is infinite
\end{proof}

\section{Fundamentals of Recursively Enumerable Sets and the Recursion Theorem}
\label{sec:org15fd8ca}
\subsection{Equivalent Definitions of Recursively Enumerable Sets}
\label{sec:orgdf0b830}
\begin{definition}[]
\begin{enumerate}
\item A set \(A\) is a \textbf{projection} of some relation
\(R\subseteq\omega\times\omega\) if \(A=\{x:(\exists y)R(x,y)\}\)
\item A set \(A\) is in \textbf{\(\Sigma_1\)-form} (abbreviated ``A is \(\Sigma_1\)'') if
\(A\) is the projection of some recursive relation \(R\subseteq\omega\times\omega\).
\end{enumerate}
\end{definition}

\begin{theorem}[Normal Form Theorem for r.e. sets]
\label{thm2.1.2}
A set \(A\) is r.e. iff \(A\) is \(\Sigma_1\)
\end{theorem}

\begin{proof}
If \(A\) is r.e., then \(A=W_e\) for some \(e\). Hence
\begin{equation*}
x\in W_e\Leftrightarrow(\exists s)[x\in W_{e,s}]\Leftrightarrow
(\exists s)T(e,x,s)
\end{equation*}
and \(T(e,x,s)\) is primitive recursive

Let \(A=\{x:(\exists y)R(x,y)\}\), where \(R\) is recursive. Then
\(A=\dom\psi\), where \(\psi(x)=(\mu y)R(x,y)\)
\end{proof}

\begin{theorem}[Quantifier Contraction Theorem]
\label{thm2.1.3}
If there is a recursive relation
\begin{equation*}
R\subseteq\omega^{n+1}
\end{equation*}
and
\begin{equation*}
A=\{x:(\exists y_1)\dots(\exists y_n)R(x,y_1,\dots,y_n)\}
\end{equation*}
then \(A\) is \(\Sigma_1\)
\end{theorem}

\begin{proof}
Define the recursive relation \(S\subseteq \omega^2\) by
\begin{equation*}
S(x,z)\Leftrightarrow R(x,(z)_1,\dots,(z)_n)
\end{equation*}
where \(z=p_1^{(z)_1}\dots p_k^{(z)_k}\)
\end{proof}

\begin{corollary}[]
\label{cor2.1.4}
The projection of an r.e. relation is r.e.
\end{corollary}

\begin{definition}[]
The \textbf{graph} of a (partial) function \(\psi\) is the relation
\begin{equation*}
(x,y)\in\graph\psi\Leftrightarrow\psi(x)=y
\end{equation*}
\end{definition}

Using Theorem \ref{thm1.3.9} the following sets and relations are r.e.:
\begin{enumerate}
\item \(K=\{e:e\in W_e\}=\{e:(\exists s,y)[\varphi_{e,s}(e)=y]\}\)
\item \(K_0=\{\la x,e\ra:x\in W_e\}=\{\la x,e\ra:(\exists s,y)[\varphi_{e,s}(x)=y]\}\)
\item \(K_1=\{e:W_e\neq0\}=\{e:(\exists s,x)[x\in W_{e,s}]\}\)
\item \(\im\varphi_e=\{y:(\exists s,x)[\varphi_{e,s}(x)=y]\}\)
\item \(\graph\varphi_e=\{(x,y):(\exists s)[\varphi_{e,s}(x)=y]\}\)
\end{enumerate}


\begin{theorem}[Uniformization Theorem]
\label{thm2.1.6}
If \(R\subseteq\omega^2\) is an r.e. relation, then there is a p.r. function
\(\psi\) (called a \textbf{selector function} for \(R\)) s.t.
\begin{equation*}
\psi(x)\downarrow\Leftrightarrow(\exists y)R(x,y)
\end{equation*}
and in this case \((x,\psi(x))\in R\)
\end{theorem}

\begin{proof}
Since\(R\) is r.e. and hence \(\Sigma_1\), there is a recursive relation
\(S\) s.t. \(R(x,y)\) holds iff \((\exists z)S(x,y,z)\). Define the p.r.
function
\begin{equation*}
\theta(x)=(\mu u)S(x,(u)_1,(u)_2)
\end{equation*}
and set \(\psi(x)=(\theta(x))_1\)
\end{proof}

\begin{theorem}[Graph Theorem]
\label{thm2.1.7}
A partial function \(\psi\) is partial recursive iff its graph is r.e.
\end{theorem}

\begin{proof}
If the graph of \(\psi\) is r.e., then \(\psi\) is its own selector function.

If \(\psi\) is p.r., there is \(e\) s.t. \(\varphi_e=\psi\)
\end{proof}

\begin{theorem}[Listing Theorem]
\label{thm2.1.8}
A set \(A\) is r.e. iff \(A=\emptyset\) or \(A\) is the range of a total
recursive function.. Furthermore, \(f\) can be found uniformly in an index
for \(A\) as explained in Exercise \ref{ex2.1.25}
\end{theorem}

\begin{proof}
Let \(A=W_e\neq\emptyset\). Find the least integer \(\la a,t\ra\) s.t
\(a\in W_{e,t}\). Define the recursive function \(f\) by
\begin{equation*}
f(\la s,t\ra)=
\begin{cases}
x&x\in W_{e,s+1}-W_{e,s}\\
a&\text{otherwise}
\end{cases}
\end{equation*}
Clearly \(A=\im f\).

If \(A\) is the range of a total recursive function, \(A\) is \(\Sigma_1\)
\end{proof}

\begin{theorem}[Union Theorem]
\label{thm2.1.9}
The r.e. sets are closed under union and intersection uniformly effectively,
namely there are recursive functions \(f\) and \(g\) s.t.
\(W_{f(x,y)}=W_x\cup W_y\), and \(W_{g(x,y)}=X_x\cap W_y\)
\end{theorem}

\begin{proof}
Using the \(s\)-\(m\)-\(n\) Theorem define \(f(x,y)\) by enumerating
\(z\in W_{f(x,y)}\) if \((\exists s)[z\in W_{x,s}\cup W_{y,s}]\)
\end{proof}

\begin{corollary}[Reduction Principle for r.e. sets]
\label{cor2.1.10}
Given any two r.e. sets \(A\) and \(B\), there exist r.e. sets
\(A_1\subseteq A\) and \(B_1\subseteq B\) s.t. \(A_1\cap B_1=\emptyset\) and
\(A_1\cup B_1=A\cup B\)
\end{corollary}

\begin{proof}
Define the relation \(R:=A\times\{0\}\cup B\times{1}\) which is r.e. by
Theorem \ref{thm2.1.9}. By the Uniformization Theorem \ref{thm2.1.6}, let \(\psi\) be
the p.r. selector function for \(R\). Let \(A_1=x:\psi(x)=0\) and
\(B_1=x:\psi(x)=1\) 
\end{proof}

\begin{definition}[]
A set \(A\) is in \textbf{\(\Delta_1\)-form} (abbreviated ``\(A\) is \(\Delta_1\)'')
if both \(A\) and \(\bar{A}\) is \(\Sigma_1\).
\end{definition}

\begin{theorem}[Complementation Theorem]
\label{thm2.1.12}
A set \(A\) is recursive iff both \(A\) and \(\bar{A}\) are r.e. (i.e., iff \(A\in\Delta_1\))
\end{theorem}

\begin{proof}
Let \(A=W_e,\bar{A}=W_i\). Define the recursive function
\begin{equation*}
f(x)=(\mu s)[x\in W_{e,s}\vee x\in W_{i,s}]
\end{equation*}
Then \(x\in A\) iff \(x\in W_{e,f(x)}\), so \(A\) is recursive
\end{proof}

\begin{corollary}[]
\label{cor2.1.13}
\(\bar{K}\) is not r.e.
\end{corollary}

\begin{definition}[]
\begin{enumerate}
\item A \textbf{lattice} \(\call=(L;\le,\vee,\wedge)\) is a partially ordered set
(poset) in which any two elements have a least upper bound and greatest
lower bound. If \(a\) and \(b\) are elements of a lattice \(\call\),
\(a\vee b\) denote the least upper bound (lub) of \(a\) and \(b\),
\(a\wedge b\) the greatest lower bound (glb). If \(\call\) contains a
least element and greatest element these are called the \textbf{zero} element and
\textbf{unit} element 1. In such a lattice \(a\) is the \textbf{complement} of \(b\) if
\(a\vee b=1\)
\item A lattice is \textbf{distributive} if all its elements satisfy the distributive
laws
\((a\vee b)\wedge c=(a\wedge c)\vee(b\wedge c)\) and
\((a\wedge b)\vee c=(a\vee c)\wedge(b\vee c)\)
\item A lattice is \textbf{complemented} if every element has a complement
\item A poset closed under suprema but not necessarily under infima is an
\textbf{upper semi-lattice}
\item \(\calm=(\la M;\le,\vee,\wedge)\) is a \textbf{sublattice} of \(\call\) if
\(M\subseteq L\) and \(M\) is closed under the operations \(\vee\) and
\(\wedge\) in \(\call\)
\item A nonempty subset \(I\subseteq L\) forms an \textbf{ideal}
\(\cali=(I,\le,\wedge,\vee)\) of \(\call\) if \(I\) satisfies the
conditions
\begin{enumerate}
\item \([a\in L\;\&\;a\le b\in I]\Longrightarrow a\in I\)
\item \([a\in I\;\&\;b\in I]\Longrightarrow a\vee b\in I\)
\end{enumerate}
\item A subset \(D\subseteq L\) forms a \textbf{filter} \(\cald=(D;\le,\wedge,\vee)\)
of \(\call\) if it satisfies the dual conditions
\begin{enumerate}
\item \([a\in L\;\&\; a\ge b\in D]\Longrightarrow a\in D\)
\item \([a\in D\;\&\; b\in D]\Longrightarrow a\wedge b\in D\)
\end{enumerate}
\item Let \(\call\) be an upper semi-lattice. The definitions of ideal and
filter are the same except that we require (2) only when \(a\wedge b\)
exists. Furthermore, we say \(\cald\) is a \textbf{strong filter} in \(\call\) if
\(\cald\) satisfies (1) and also:
\begin{enumerate}
\item \([a\in\cald\;\&\;b\in\cald]\Leftrightarrow(\exists c\in\cald)
         [c\le a\;\&\;c\le b]\)
\end{enumerate}
\end{enumerate}
\end{definition}

The collection of all subsets of \(\omega\) forms a Boolean algebra,
\(\caln=(2^\omega;\subseteq,\cup,\cap)\) with \(\emptyset\) as least element
and \(\omega\) as the greatest element. The finite sets form an ideal \(\calf\)
of \(\caln\) and the cofinite sets form a filter \(\calc\) in \(\caln\)


\begin{definition}[]
\begin{enumerate}
\item By Theorem \ref{thm2.1.9} the r.e. sets form a distributive lattice
\(\cale\) under inclusion with greatest element \(\omega\) and least element \(\emptyset\)
\item By Theorem \ref{thm2.1.12} an r.e. set \(A\in\cale\) is recursive iff
\(\bar{A}\in\cale\). Hence the recursive sets form a Boolean algebra \(\calr\subseteq\cale\).
\end{enumerate}
\end{definition}
\subsubsection{exercise}
\label{sec:orgee80b8c}

\begin{exercise}
\label{2.1.16}
\begin{enumerate}
\item Prove that \(A\le_m B\) and \(B\) r.e. imply \(A\) r.e.
\item Show that \(\Fin\) and \(\Tot\) are not r.e.
\item Show that \(\Cof\) is not r.e.
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item Let \(f:A\to B\), then \(A=\{a:(\exists b)((a,b)\in\graph f)\}\) ?
\end{enumerate}
\end{proof}

\begin{exercise}
\label{2.1.17}
Prove that if \(A\) is r.e. and \(\psi\) is p.r. then \(\psi(A)\) is r.e. and
\(\psi^{-1}(A)\) is r.e.
\end{exercise}

\begin{proof}
Let \(\psi=\varphi_e\) and \(\psi(A)=\{y: (\exists s,x)\varphi_{e,s}(x)=y\}\)
\end{proof}

\begin{exercise}
\label{ex2.1.18}
Prove that if \(f\) is recursive, then \(\graph f\) is recursive
\end{exercise}

\begin{exercise}
\label{ex2.1.19}
A function \(f\) is \textbf{increasing} if \(f(x)<f(x+1)\) for all \(x\). Show that
an infinite set \(A\) is recursive iff \(A\) is the range of an increasing
recursive function
\end{exercise}

\begin{proof}
\begin{equation*}
\chi_A(x)=
\begin{cases}
1&(\exists y<x)f(y)=x\\
0
\end{cases}
\end{equation*}
\end{proof}

\begin{exercise}
\label{ex2.1.20}
Prove that any infinite r.e. set is the range of a 1:1 recursive function
\end{exercise}

\begin{exercise}
\label{ex2.1.21}
Prove that every infinite r.e. set contains an infinite recursive subset
\end{exercise}

\begin{exercise}
\label{ex2.1.22}
A set \(A\) is \textbf{co-r.e.} (or equivalently \(\Pi_1\)) if \(\bar{A}\) is r.e.
Use Exercise \ref{ex1.4.22} to prove that the reduction principle fails for \(\Pi_1\) sets
\end{exercise}

\begin{exercise}
\label{ex2.1.23}
The \textbf{separation principle} holds for a class \(\calc\) of sets if for every
\(A,B\in\calc\) s.t. \(A\cap B=\emptyset\) there exists \(C\) s.t.
\(C,\bar{C}\in\calc\), \(A\subseteq C\) and \(B\subseteq\bar{C}\). By
Exercise \ref{ex1.4.22} the separation fails  for r.e. sets. Use Corollary
\ref{cor2.1.10} to show that the separation principle holds for co-r.e. sets
\end{exercise}

\begin{exercise}
\label{ex2.1.24}
Prove that if \(A\le_1 B\) and \(A\) and \(B\) are r.e. and \(A\) is
infinite then \(A\le_1 B\) via some \(f\) s.t. \(f(A)=B\)
\end{exercise}

\begin{exercise}
\label{ex2.1.25}
Show that the proof of Theorem \ref{thm2.1.8} is uniform in \(e\) in the sense
that there is a p.r. function \(\psi(e,y)\) s.t. if \(W_e\neq0\) then
\(\lambda y\psi(e,y)\) is total and \(W_e=\{\psi(e,y):y\in\omega\}\). 
\end{exercise}
\subsection{Uniformity and Indices for Recursive and Finite Sets}
\label{sec:org666da36}
A theorem will be said to hold \textbf{uniformly} if such an effective procedure
exists.

\begin{definition}[]
\begin{enumerate}
\item We say that \(e\) is \textbf{\(\Sigma_1\)-index} (r.e. index) for a set \(A\) if
\(A=W_e=\{x: (\exists y)T(e,x,y)\}\)
\item \(\la e,i\ra\) is a \textbf{\(\Delta_1\)-index} for a recursive set \(A\) if
\(A=W_e\) and \(\bar{A}=W_i\)
\item \(e\) is a \textbf{\(\Delta_0\)-index} (\textbf{characteristic index}) for \(A\) if
\(\varphi_e\) is the characteristic function for \(A\)
\end{enumerate}
\end{definition}

\begin{theorem}[]
\label{thm2.2.2}
There is no p.r. function \(\psi\) s.t. if \(W_x=A\) and \(A\) is recursive then
\(\psi(x)\) converges and \(W_{\psi(x)}=\bar{A}\). (There is no uniformly
effective way to pass from \(\Sigma_1\)-indices to \(\Delta_0\)-indices for
recursive sets)
\end{theorem}

\begin{proof}
Define the recursive function \(f\) by
\begin{equation*}
W_{f(x)}=
\begin{cases}
\omega&x\in K\\
\emptyset
\end{cases}
\end{equation*}
Now
\begin{align*}
&x\in K\Longrightarrow W_{f(x)}=\omega\Longrightarrow W_{\psi f(x)}=\emptyset\\
&x\not\in K\Longrightarrow W_{f(x)}=\emptyset\Longrightarrow W_{\psi f(x)}=\omega\\
\end{align*}
Hence
\begin{equation*}
x\in\bar{K}\Longleftrightarrow W_{\psi f(x)}\neq\emptyset\Longleftrightarrow
(\exists y,s)[y\in W_{\psi f(x),s}]
\end{equation*}
so \(\bar{K}\) is \(\Sigma_1\) and hence r.e., contradicting Corollary \ref{cor2.1.13}
\end{proof}

\begin{corollary}[]
\label{cor2.2.3}
The recursive sets are closed under \(\cup,\cap\) and complementation. The
closure under \(\cup\) and \(\cap\) is uniformly effective w.r.t. both
\(\Sigma_1\) and \(\Delta_1\)-indices. The closure under complementation is
uniformly effective w.r.t. \(\Delta_1\)-indices
\end{corollary}

A finite set, being recursive, has both a \(\Sigma_1\)-index and
\(\Delta_0\)-index.

\begin{definition}[]
\begin{enumerate}
\item Given a finite set \(A=\{x_1,\dots,x_k\}\), where \(x_1<x_2<\dots<x_k\),
the number \(y=2^{x_1}+\dots+2^{x_k}\) is the \textbf{canonical index} of \(A\).
Let \(D_y\) denote finite set with canonical index \(y\) and \(D_0\)
denote \(\emptyset\)
\item A sequence \(\{D_{f(x)}\}_{x\in\omega}\) for some recursive function \(f\)
is called a \textbf{recursive sequence} or a \textbf{strong array} of finite sets.
\end{enumerate}
\end{definition}

There is no p.r. function \(\psi\) s.t. if \(\varphi_x\) is the characteristic
function of \(D_y\), then \(\psi(x)\) converges and \(\psi(x)=\abs{D_y}\).
(If \(\psi\) exists, define \(\varphi_{f(x)}(s)=1\) if \(x\in K_{s+1}-K_s\) and
\(\varphi_{f(x)}(s)=0\) otherwise. Thus \(\psi\circ f\) is actually the
characteristic function of \(K\))

\begin{definition}[]
\begin{enumerate}
\item A sequence \(\{V_n\}_{n\in\omega}\) of r.e. sets is \textbf{uniformly r.e.}
(\textbf{u.r.e}), also called \textbf{simultaneously r.e.} (\textbf{s.r.e.}) if there is a
recursive function \(f\) s.t. \(V_n=W_{f(n)}\) for all \(n\)
\item A sequence \(\{V_n\}_{n\in\omega}\) of recursive sets is \textbf{uniformly
recursive} if there is a recursive function \(g(x,n)\) s.t.
\(\lambda x[g(x,n)]\) is the characteristic function of \(V_n\) for all \(n\)
\end{enumerate}
\end{definition}

From now on we assume that we have define \(\varphi_{e,s}\) and \(W_{e,s}\)
using Exercise \ref{ex1.3.11}

\begin{definition}[]
A \textbf{recursive enumeration} (usually called simply an \textbf{enumeration}) of an r.e.
set \(A\) consists of a strong array \(\{A_s\}_{s\in\omega}\) (of finite
sets) s.t. \(A_s\subseteq A_{s+1}\) and \(A=\bigcup_s A_s\)
\end{definition}

For example, \(\{W_{e,s}\}_{s\in\omega}\) is an enumeration of \(W_e\)

\begin{definition}[]
\begin{enumerate}
\item A \textbf{simultaneous (recursive) enumeration} of a u.r.e. sequence
\(\{V_n\}_{n\in\omega}\) of r.e. sets is a strong array
\(\{V_{n,s}\}_{n,s\in\omega}\) s.t. for all \(s,n\in\omega\)
\begin{enumerate}
\item \(V_{n,s}\subseteq V_{n,s+1}\)
\item \(\abs{V_{n,s+1}-V_{n,s}}\le1\)
\item \(V_n=\bigcup_{s\in\omega}V_{n,s}\)
\end{enumerate}
\item A \textbf{standard enumeration} (of the r.e. sets) is a simultaneous enumeration
of \(\{V_n\}_{n\in\omega}\) where \(\{V_n\}_{n\in\omega}\) is some
acceptable numbering of the r.e. sets as defined in Exercise \ref{ex1.5.9}
\end{enumerate}
\end{definition}

For example, an easy way to give a simultaneous enumeration of any u.r.e.
sequence \(\{V_n\}_{n\in\omega}\) is to choose a 1:1 recursive function \(f\)
with range \(\{\la x,n\ra:x\in V_n\}\) and to define
\begin{equation*}
V_{n,s}=\{x: (\exists t<s)[f(t)=\la x,n\ra]\}
\end{equation*}

\begin{definition}[]
Let \(\{X_s\}_{s\in\omega}\) and \(\{Y_s\}_{s\in\omega}\) be recursive
enumeration of r.e. sets \(X\) and \(Y\)
\begin{enumerate}
\item Define \(X\setminus Y=\{z: (\exists s)[z\in X_s-Y_s]\}\), the elements
enumerated in \(X\) before (if ever) being enumerated in \(Y\)
\item Define \(X\searrow Y=(X\setminus Y)\cap Y\), the elements enumerated in
\(X\) and later in \(Y\)
\end{enumerate}
\end{definition}
\subsubsection{Exercises}
\label{sec:org476bfb6}
\begin{exercise}
\label{2.2.10}
\begin{enumerate}
\item Given recursive enumeration \(\{X_s\}_{s\in\omega}\) and
\(\{Y_s\}_{s\in\omega}\) of r.e. sets \(X\) and \(Y\) prove that both
\(X\setminus Y\) and \(X\searrow Y\) are r.e. sets
\item Prove that \(X\setminus Y=(X-Y)\cup(X\searrow Y)\)
\item Prove that if \(X-Y\) is nonrecursive then \(X\searrow Y\) is infinite
\item Give an alternative proof of Corollary \ref{cor2.1.10} by letting
\(A_1=W_x\setminus W_y\) and \(B_1=W_y\setminus W_x\) where \(W_x=A\) and \(W_y=B\)
\item Let \(f\) be a 1:1 recursive function from \(\omega\) onto \(K_0\). Define
\begin{equation*}
W_{e,s}=\{x: (\exists t\le s)[f(t)=\la x,e\ra]\}
\end{equation*}
Show that \(\{W_{e,s}:e,s\in\omega\}\) satisfies condition
\begin{equation*}
(\forall s)(\exists\text{ at most one }\la e,x\ra)[x\in W_{e,s+1}-W_{e,s}]
\end{equation*}
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item Prove \((x,z)\) is recursive
\setcounter{enumi}{2}
\item 

\setcounter{enumi}{3}
\item \(W_x=\{W_{x,s}\}_{s\in\omega}\)
\end{enumerate}
\end{proof}

\begin{exercise}
\label{ex2.2.11}
Prove that there is a recursive function \(f\) s.t.
\(\{W_{f(n)}\}_{n\in\omega}\) consists precisely of the recursive sets.
Hence we can give an effective list of \(\Sigma_1\)-indices for the
recursive sets but not of \(\Delta_1\)-indices
\end{exercise}

\begin{proof}
Obtain \(W_{f(n)}\subseteq W_n\) by enumerating \(W_n\), placing in
\(W_{f(n)}\) only those elements enumerated in increasing order, and
applying Exercise \ref{ex2.1.19}. Note that we are using the uniformity shown
in Exercise \ref{ex2.1.25}
\end{proof}

\begin{exercise}
\label{ex2.1.12}
Prove that there is a recursive function \(f(e,s)\) s.t.
\(D_{f(e,s)}=W_{e,s}\) and hence that \(W_e=\bigcup_sD_{f(e,s)}\)
\end{exercise}

\begin{exercise}
\label{ex2.1.13}
Prove that there are recursive functions \(f\) and \(g\) s.t.
\(D_x\cup D_y=D_{f(x,y)}\) and \(D_x\cap D_y=D_{g(x,y)}\)
\end{exercise}
\subsection{The Recursion Theorem}
\label{sec:orgd763675}
\begin{theorem}[Recursion Theorem (Kleene)]
\label{thm2.3.1}
For every recursive function \(f\) there exists an \(n\) (called a \textbf{fixed
point} of \(f\)) s.t. \(\varphi_n=\varphi_{f(n)}\)
\end{theorem}

\begin{proof}
Define the recursive ``diagonal'' function \(d(u)\) by
\begin{equation*}
\varphi_{d(u)}(z)=
\begin{cases}
\varphi_{\varphi_u(u)}(z)&\varphi_u(u)\text{ converges}\\
\text{undefined}&\text{otherwise}\\
\end{cases}
\end{equation*}
Note that \(d\) is 1:1 and total by the \(s\)-\(m\)-\(n\) theorem. Note also
that \(d\) is independent of \(f\).

Given \(f\), choose an index \(v\) s.t.
\begin{equation*}
\varphi_v=f\circ d
\end{equation*}
We claim that \(n=d(v)\) is a fixed point of \(f\). First note that \(f\)
total implies \(fd\) is total, so \(\varphi_v(v)\) converges and
\(\varphi_{d(v)}=\varphi_{\varphi_v(v)}\). Now
\begin{equation*}
\varphi_n=\varphi_{d(v)}=\varphi_{\varphi_v(v)}=\varphi_{fd(v)}=\varphi_{f(n)}
\end{equation*}
\end{proof}

\begin{corollary}[]
\label{cor2.3.2}
For every recursive function \(f\), there exists \(n\) s.t. \(W_n=W_{f(n)}\)
\end{corollary}

\begin{remark}
From \cite{DBLP:journals/ndjfl/Owings73}.

In a typical diagonal argument there is a square array of objects
\(\{\alpha_{x,u}\}_{x,u\in\omega}\) and one constructs a sequence
\(D'=\{\alpha'_x\}_{x\in\omega}\) s.t. \(\alpha_x'\neq\alpha_{x,x}\), where
\(D=\{\alpha_{x,x}\}_{x\in\omega}\) is the diagonal sequence, and hence
\(D'\) is \textbf{not} one of the rows, \(R_u=\{\alpha_{x,u}\}_{x\in\omega}\).

Now
consider the matrix where \(\alpha_{x,u}=\varphi_{\varphi_u(x)}\), and where
it is understood that \(\alpha_{x,u}\) and \(\varphi_{\varphi_u(x)}\) denote
the totally undefined function if \(\varphi_u(x)\) diverges. Here the strong
closure properties of the partial recursive functions under the
\(s\)-\(m\)-\(n\) Theorem guarantee that the diagonal sequence
\(D=\{\alpha_{x,x}\}_{x\in\omega}\) \textbf{is} one of the rows, namely the \(e\)-th
row, \(R_e=\{\varphi_{\varphi_e(x)}\}_{x\in\omega}\), where \(\varphi_e=d\).
Equivalently, for any \(x\), \(d(x)=\varphi_x(x)\). This is obviously computable.

Now any recursive function \(f\) induces a transformation on the rows
\(R_u=\{\varphi_{\varphi_u(x)}\}_{x\in\omega}\) of this matrix, mapping
\(R_u\) to the row \(\{\varphi_{f\varphi_u(x)}\}_{x\in\omega}\). In
particular, \(f\) maps the ``diagonal'' row
\(R_e=\{\varphi_{d(x)}\}_{x\in\omega}\) to
\(R_v=\{\varphi_{fd(x)}\}_{x\in\omega}\). Since \(R_e\) is the diagonal
sequence, the \(v\)th element of the sequence, namely
\(\varphi_{d(v)}=\varphi_{\varphi_v(v)}\), must be unchanged by this action
of \(f\), and hence \(\varphi_{d(v)}=\varphi_{fd(v)}\)
\end{remark}

A typical application of the Recursion Theorem is that there exists \(n\)
s.t. \(W_n=\{n\}\). (By the \(s\)-\(m\)-\(n\) Theorem define
\(W_{f(x)}=\{x\}\) and by the Recursion Theorem choose \(n\) s.t.
\(W_n=W_{f(n)}=\{n\}\))

\begin{proposition}[]
In the Recursion Theorem, \(n\) can be computed from an index for \(f\) by a
1:1 recursive function \(g\)
\end{proposition}

\begin{proof}
Let \(v(x)\) be a recursive function s.t.
\(\varphi_{v(x)}=\varphi_x\circ d\). Let \(g(x)=d(v(x))\). Both \(d\) and
\(v\) are 1:1 by the \(s\)-\(m\)-\(n\) Theorem
\end{proof}

\begin{proposition}[]
In the Recursion Theorem, there is an infinite r.e. set of fixed points for \(f\).
\end{proposition}

\begin{proof}
By the Padding Lemma \ref{lemma1.3.2} there is an infinite r.e. set \(V\) of
indices \(v\) s.t. \(\varphi_v=f\circ d\), but \(d\) is 1:1 so
\(\{d(v)\}_{v\in V}\) in infinite and r.e.
\end{proof}

\begin{theorem}[Recursion Theorem with Parameters (Kleene)]
\label{thm2.3.5}
If \(f(x,y)\) is a recursive function, then there is a recursive function
\(n(y)\) s.t. \(\varphi_{n(y)}=\varphi_{f(n(y),y)}\)
\end{theorem}

\begin{proof}
Define a recursive function \(d\) by
\begin{equation*}
\varphi_{d(x,y)}(z)=
\begin{cases}
\varphi_{\varphi_x(x,y)}(z)&\varphi_x(x,y)\text{ converges}\\
\text{undefined}&\text{otherwise}
\end{cases}
\end{equation*}
Choose \(v\) s.t. \(\varphi_v(x,y)=f(d(x,y),y)\). Then \(n(y)=d(v,y)\) is a
fixed point, since \(\varphi_{d(v,y)}=\varphi_{\varphi_v(v,y)}=\varphi_{f(d(v,y),y)}\)
\end{proof}

Informally, the Recursion Theorem allows us to define a p.r. function
\(\varphi_n\) (or an r.e. set \(W_n\)) using its own index \(n\) in advance
as part of the algorithm, \(\varphi_n(z):\dots n\dots\). This circularity is
removed by the Recursion Theorem because we are really using the
\(s\)-\(m\)-\(n\) Theorem to define a function
\(f(x)\),\(\varphi_{f(x)}(z):\dots x\dots\) and then taking a fixed point
\(\varphi_n(z)=\varphi_{f(n)}(z):\dots n\dots\) The only restriction on the
informal method is that we cannot use in the program any special properties
of \(\varphi_n\) (such as \(\varphi_n\) being total or \(W_n\neq\emptyset\)).
For example, if for all \(x\) the function \(\varphi_{f(x)}\) being defined
is total, then the fixed point \(\varphi_{f(x)}=\varphi_n\) will be total.
However, the instructions for \(\varphi_{f(x)}\) must not say ``wait until
\(\varphi_{x}(z)\) converges, take the value \(v=\varphi_x(z)\) and do \(\dots\)''

\begin{theorem}[]
\label{thm2.3.6}
There is no r.e. function \(\psi\) s.t. if \(W_x\) is recursive then \(\psi(x)\)
converges and \(\varphi_{\psi(x)}\) is the characteristic function for
\(W_x\). Equivalent to Theorem \ref{thm2.2.2}
\end{theorem}

\begin{proof}
Using the Recursion Theorem define a recursive set
\begin{equation*}
W_n=
\begin{cases}
\{0\}&\psi(n)\downarrow\;\&\;
\varphi_{\psi(n)}(0)\downarrow=0\\
\emptyset&\text{otherwise}
\end{cases}
\end{equation*}
Now \(\varphi_{\psi(n)}\) cannot be the characteristic function of \(W_n\)
because \(0\in W_n\) iff \(\varphi_{\psi(n)}(0)=0\)
\end{proof}

\begin{theorem}[]
\label{thm2.3.7}
If \(\psi(x,y)\) is a partial recursive function, then there is a recursive
function \(n(y)\) s.t.
\begin{equation*}
(\forall y)[\psi(n(y),y)\downarrow\Longrightarrow\varphi_{n(y)}=\varphi_{\psi(n(y),y)}]
\end{equation*}
\end{theorem}

\begin{proof}
Same as Theorem \ref{thm2.3.5}
\end{proof}
\subsubsection{Exercises}
\label{sec:org7415cc2}
\begin{exercise}
\label{ex2.3.8}
A set \(A\) is \textbf{self-dual} if \(A\le_m\overbar{A}\). For example if
\(A=B\oplus\overbar{B}\) then \(A\) is self-dual
\begin{enumerate}
\item Use the Recursion Theorem to prove that no index set \(A\) can be self-dual
\item Give a short proof of Rice's Theorem \ref{cor1.4.13}
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item Suppose \(f:A\le_m\overbar{A}\). \(f\) is recursive and there is some
\(n\) that \(\varphi_n=\varphi_{f(n)}\). However, \(x\in A\) iff \(f(x)\in\overbar{A}\)
\item If a recursive set is non-trivial, then it's self-dual

\begin{equation*}
f(x)=
\begin{cases}
\mu y(\chi_A(y)=0)&\chi_A(x)=1\\
\mu y(\chi_A(y)=1)&\chi_A(x)=0
\end{cases}
\end{equation*}
\end{enumerate}
\end{proof}

\begin{exercise}
\label{ex2.3.9}
Show that for any p.r. function \(\psi(x,y)\) there is an \(n\) s.t. \(\varphi_n(y)=\psi(n,y)\)
\end{exercise}

\begin{proof}
\(\psi(n,y)=\varphi_{f(n)}(y)=\varphi_n(y)\)
\end{proof}

\begin{exercise}
\label{ex2.3.10}
Show that Corollary \ref{cor2.3.2} is equivalent to: For every r.e. set \(A\),
\((\exists n)[W_n=\{x:\la x,n\ra\in A\}]\)
\end{exercise}

\begin{proof}
Suppose \(A=W_e\) and \(\varphi_{f(n)}(x)=\varphi_e(x,n)\). Hence
there exists \(n'\) s.t. \(\varphi_{n'}(x)=\varphi_e(x,n')\)
\end{proof}

\begin{exercise}
\label{ex2.3.11}
Use the informal technique in Theorem \ref{thm2.3.6} to show that there is no
p.r. function \(\varphi_e\) s.t. if \(\varphi_x\) is the characteristic
function of a finite set \(F\), then \(\varphi_e(x)\downarrow=\max(F)\).
\end{exercise}

\begin{proof}
Define
\begin{equation*}
\varphi_n(t+1)=
\begin{cases}
1&t=(\mu s)[\varphi_{e,s}(n)\downarrow]\\
0&\text{otherwise}
\end{cases}
\end{equation*}
Note that
\begin{equation*}
\varphi_{e,s}(x)=y\Longrightarrow e,x,y<s
\end{equation*}
\end{proof}
\subsection{Complete Sets, Productive Sets and Creative Sets}
\label{sec:org0c6e139}
\begin{definition}[]
Let \(r=1\), \(m\) or \(T\). A set \(A\) is \textbf{\(r\)-complete} if \(A\) is r.e.
and \(W\le_r A\) for every r.e. set \(W\)
\end{definition}

\begin{theorem}[]
\label{thm2.4.2}
The sets \(K,K_0,K_1\) are all 1-complete
\end{theorem}

\begin{definition}[]
\begin{enumerate}
\item A set \(P\) is \textbf{productive} if there is a p.r. function \(\psi(x)\),
called a \textbf{productive function} for \(P\), s.t.
\begin{equation*}
(\forall x)[W_x\subseteq P\Longrightarrow[\psi(x)\downarrow\;
\&\;\psi(x)\in P-W_x]]
\end{equation*}
\item An r.e. set \(C\) is \textbf{creative} if \(\overbar{C}\) is productive
\end{enumerate}
\end{definition}

For example, the set \(K\) is creative since \(\overbar{K}\) is productive
via the identity function \(\psi(x)=x\). Since \(K\equiv K_0\equiv K_1\), we
know that \(K_0\) and \(K_1\) are also creative

A creative set \(C\) is ``effectively nonrecursive'' in the sense that for any
candidate \(W_x\) for \(\overbar{C}\), \(\psi(x)\) is an effective
counterexample; namely \(\psi(x)\in\overbar{C}-W_x\)

\begin{theorem}[]
Any productive set \(P\) has a 1:1 total recursive productive function \(p\)
\end{theorem}

\begin{proof}
Let \(P\) be productive via \(\psi\). First obtain a \textbf{total} productive function
\(q\) for \(P\) as follows. Define a recursive function \(g\) s.t.
\begin{equation*}
W_{g(x)}=
\begin{cases}
W_x&\psi(x)\downarrow\\
\emptyset&\text{otherwise}
\end{cases}
\end{equation*}
Define \(q(x)\) to be either \(\psi(x)\) or \(\psi(g(x))\), whichever
converges first. Now if \(W_x\subseteq P\), then \(\psi(x)\) converges and
\(W_{g(x)}=W_x\) so both \(\psi(g(x))\) and \(\psi(x)\) are in \(P-W_x\).

Now convert \(q\) to a 1:1 productive function \(p\). Let
\(W_{h(x)}=W_x\cup\{q(x)\}\). Note that
\begin{equation*}
W_x\subseteq P\Longrightarrow W_{h(x)}\subseteq P
\end{equation*}
Define \(p(0)=q(0)\). To compute \(p(x+1)\), enumerate the set
\(\{q(x+1),qh(x+1),qh^2(x+1),\dots\}\) until either: some \(y\) not in
\(\{p(0),\dots,p(x)\}\) is found; or a repetition occurs. In the former case,
set \(p(x+1)=y\). In the latter case, \(W_{x+1}\subsetneq P\), and we can set
\(p(x+1)=(\mu y)[y\not\in\{p(0),\dots,p(x)\}]\)
\end{proof}

\begin{theorem}[]
\begin{enumerate}
\item If \(P\) is productive, then \(P\) is not r.e.
\item If \(P\) is productive, then \(P\) contains an infinite r.e. set \(W\)
\item If \(P\) is productive and \(P\le_m A\) then \(A\) is productive
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\setcounter{enumi}{1}
\item Let \(W_n=\emptyset\), and \(W_{h(x)}=W_x\cup\{p(x)\}\). Define
\begin{equation*}
W=\{p(n),ph(n),ph^2(n),\dots\}
\end{equation*}
\item Let \(P\le_m A\) via \(f\), and \(p\) is a productive function for \(P\).
Let \(W_{g(x)}=f^{-1}(W_x)\). Then \(fpg\) is a productive function for \(A\)
\end{enumerate}
\end{proof}

\begin{theorem}[Myhill]
\begin{enumerate}
\item If \(P\) is productive then \(\overbar{K}\le_1 P\)
\item If \(C\) is creative then \(C\) is 1-complete and \(C\equiv K\)
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\item Let \(p\) be a total 1:1 productive function for \(P\). Define the
recursive function \(f\) by
\begin{equation*}
W_{f(x,y)}=
\begin{cases}
\{p(x)\}&y\in K\\
\emptyset&\text{otherwise}
\end{cases}
\end{equation*}
By the Recursion Theorem with Parameters \ref{thm2.3.5}, there is a 1:1
recursive function \(n(y)\) s.t.
\begin{equation*}
W_{n(y)}=W_{f(n(y),y)}=
\begin{cases}
\{p(n(y))\}&y\in K\\
\emptyset&\text{otherwise}
\end{cases}
\end{equation*}
Now
\begin{equation*}
y\in K\Longrightarrow W_{n(y)}=\{pn(y)\}\Longrightarrow
W_{n(y)}\not\subseteq P\Longrightarrow pn(y)\in\overbar{P}
\end{equation*}
and
\begin{equation*}
y\in\overbar{K}\Longrightarrow W_{n(y)=\emptyset}\Longrightarrow
W_{n(y)}\subseteq P\Longrightarrow pn(y)\in P
\end{equation*}
\item Follows from (1)
\end{enumerate}
\end{proof}

\begin{corollary}[]
The following are equivalent
\begin{enumerate}
\item \(P\) is productive
\item \(\overbar{K}\le_1 P\)
\item \(\overbar{K}\le_m P\)
\end{enumerate}
\end{corollary}

\begin{corollary}[]
The following are equivalent
\begin{enumerate}
\item \(C\) is creative
\item \(C\) is 1-complete
\item \(C\) is \(m\)-complete
\end{enumerate}
\end{corollary}

\begin{definition}[]
Let \((A_1,A_2)\) and \((B_1,B_2)\) be two pairs of sets s.t.
\(A_1\cap A_2=\emptyset=B_1\cap B_2\). Then \((B_1,B_2)\le_m(A_1,A_2)\) if
there is a recursive function s.t. \(f(B_1)\subseteq A_1\),
\(f(B_2)\subseteq A_2\) and
\(f(\overbar{B_1\cup B_2})\subseteq\overbar{A_1\cup A_x}\). We write
\(\le_1\) if \(f\) is 1:1
\end{definition}
\section{Turing Reducibility and the Jump Operator}
\label{sec:org3e6d2c8}
\subsection{Definitions of Relative Computability}
\label{sec:org26a4401}
\begin{definition}[]
Let \(A\subseteq\omega\). A partial function \(\psi\) is \textbf{partial recursive in
\(A\)} (\textbf{\(A\)-partial recursive}) if there is a derivation of \(\psi\) using
schemata (1)-(6) of Section \ref{sec-1.2} with \(\chi_A\) added as a new
initial function
\end{definition}

An \textbf{oracle Turing machine} is a Turing machine with an extra ``read only''
tape, called the \textbf{oracle tape}, upon which is written the characteristic
function of some set \(A\) (called the \textbf{oracle}), and whose symbols cannot be
printed over. The old tape is called the \textbf{work tape}. The reading head moves
along both tapes simultaneously. As before, let \(Q\) be a finite set of
states, \(\Sigma_1\) the oracle tape alphabet \(\{B,0,1\}\), \(\Sigma_2\) the
work tape alphabet \(\{B,1\}\) and \(\{R,L\}\). A \textbf{Turing program} is now
simply a partial map
\begin{equation*}
\delta:Q\times\Sigma_1\times\Sigma_2\to Q\times\Sigma_2\times\{R,L\}
\end{equation*}
where \(\delta(q,a,b)=(p,c,X)\) indicates that the machine in state \(q\)
reading symbol \(a\) on the oracle tape and symbol \(b\) on the work tape
passes to state \(p\), prints ``\(c\)'' over ``\(b\)'' on the work tape and moves
one space right (left) on both tapes if \(X=R\) (\(X=L\))

\begin{center}
\begin{tikzpicture}[every node/.style={block},
     block/.style={minimum height=2em,outer sep=0pt,draw,rectangle,node distance=0pt}]
\node (A) [block] {1};
\node (B) [left=of A,block,label={[label distance=1cm]180:work tape}] {B};
\node (D) [right=of A,block] {1};
\node (E) [right=of D,block] {1};
\node (H) [right=of E,block] {B};
\node (F) [above = 0.75cm of A,thick,block,label={[label distance=1.46cm]180:reading head}] {\textsf q,p};
\node (I) [above = 0.75cm of F,block] {$\chi_A(0)$};
\node (J) [left=of I,block,label={[label distance=1cm]180:oracle tape}] {B};
\node (K) [right=of I,block] {$\chi_A(1)$};
\node (L) [right=of K,block] {$\chi_A(2)$};
\node (N) [right=of L,block] {$\chi_A(3)$};
\draw[-latex] (F) -- (A);
\draw[-latex] (F) -- (I);
\draw (B.north west) -- ++(-1cm,0) (B.south west) -- ++ (-1cm,0)
              (H.north east) -- ++(1cm,0) (H.south east) -- ++ (1cm,0);
\draw (J.north west) -- ++(-1cm,0) (J.south west) -- ++ (-1cm,0)
              (N.north east) -- ++(1cm,0) (N.south east) -- ++ (1cm,0);
\end{tikzpicture}
\end{center}


Let \(y+1\) be the number of nonblank cells on the oracle tape which are
scanned be the reading head during the computation. (Namely, \(y\) is the
maximum integer which is tested for membership in \(A\)). We say that the
elements \(z\le y\) are \textbf{used} in the computation

These new oracle Turing programs being finite sets of 6-tuples of the above
symbols can be effectively coded. Let \(\widehat{P}_e\) denote the \(e\)th
such program under some effective coding. Note that \(\widehat{P}_e\) is
\textbf{independent} of the oracle \(A\)

\begin{definition}[]
\begin{enumerate}
\item A partial function \(\psi\) is \textbf{Turing computable in \(A\)} (\textbf{\(A\)-Turing
computable}), written \(\psi\le_T A\), if there is a program
\(\widehat{P}_e\) s.t. if the machine has \(\chi_A\) written on the oracle
tape, then for all \(x\) and \(y\), \(\psi(x)=y\) iff \(\widehat{P}_e\) on
input \(x\) halts and yields output \(y\). In this case, we write
\(\psi=\{e\}^A\), or equivalently \(\psi=\Phi_e^A\), or
\(\psi=\Phi_e(A)\). We say \(\psi(x)\) \textbf{diverges} (written
\(\psi(x)\uparrow\)) iff \(\widehat{P}_e\) on input \(x\) never halts
\item We also allow (total) functions as oracles by defining \(\{e\}^f\) to be
\(\{e\}^A\) where \(A=\graph(f)\)
\end{enumerate}
\end{definition}

\begin{theorem}[]
A partial function \(\psi\) is \(A\)-partial recursive iff \(\psi\) is \(A\)-Turing computable
\end{theorem}

\begin{theorem}[Relativized Enumeration Theorem]
There exists \(z\in\omega\) s.t. for all sets \(A\subseteq\omega\) and for
all \(x,y\in\omega\) the \(A\)-partial recursive function \(\Phi_z^A(x,y)\)
satisfies \(\Phi_z^A(x,y)=\Phi_x^A(y)\)
\end{theorem}

\begin{theorem}[Relativized $s$-$m$-$n$ Theorem]
For every \(m,n\ge1\) there exists a 1:1 recursive function \(s_n^m\) of
\(m+1\) variables s.t. for all sets \(A\subseteq\omega\) and for all
\(x,y_1,\dots,y_m\in\omega\),
\begin{equation*}
\Phi_{s^m_n(x,y_1,\dots,y_m)}^A=\lambda z_1,\dots,z_n[
\Phi_x^A(y_1,\dots,y_m,z_1,\dots,z_n)]
\end{equation*}
\end{theorem}

\begin{theorem}[Relativized Recursion Theorem]
\begin{enumerate}
\item For all sets \(A\subseteq\omega\) and all \(x,y\in\omega\), if \(f(x,y)\)
is an \(A\)-recursive function, then there is a recursive function
\(n(y)\) s.t. \(\Phi_{n(y)}^A=\Phi_{f(n(y),y)}^A\)
\item Furthermore, \(n(y)\) does not depend upon the oracle \(A\), namely if
\begin{equation*}
f(x,y)=\{e\}^A(x,y)
\end{equation*}
then the recursive function \(n(y)\) can be found uniformly in \(e\)
\end{enumerate}
\end{theorem}

Note that the strings \(\sigma\) of 0's and 1's, namely \(\sigma\in2^{<\omega}\),
are to be viewed as finite initial segments of characteristic functions. We
identify a set \(A\) with its characteristic function and write
\(\sigma\subset A\) if \(\sigma\subseteq\chi_A\) as a partial function,
namely \(\sigma(x)=\chi_A(x)\) for all \(x\in\dom\sigma\). Then \textbf{length} of
\(\sigma\), written \(\lh(\sigma)\), is \(\abs{\dom\sigma}\). Note that
\(\lh(\sigma)=\mu x[\sigma(x)\uparrow]\). If \(n=\lh(\sigma)\), then
\(\sigma=\sigma\restriction n\)

\begin{definition}[]
\begin{enumerate}
\item We write \(\{e\}_s^A(x)=y\) if \(x,y,e<s\),\(s>0\),\(\{e\}^A(x)=y\) in
\(<s\) steps according to program \(\widehat{P}_e\), and only numbers
\(z<s\) are used in the computation
\item The \textbf{use function} \(u(A;e,x,s)\) is 1+ the maximum number used in the
computation if \(\{e\}^A_s(x)\downarrow\), and =0 otherwise. The use
function \(u(A;e,x)\) is \(u(A;e,x,s)\) if \(\{e\}_s^A(x)\downarrow\) for
some \(s\), and is undefined if \(\{e\}^A(x)\uparrow\)
\item We write \(\{e\}_s^\sigma(x)=y\) if \(\{e\}_s^A(x)=y\) for some
\(A\supset\sigma\) and only elements \(z<\lh(\sigma)\) are used in the
computation. If such \(\sigma=A\restriction u\) we also write
\(\{e\}_s^{A\restriction u}(x)=y\). (The definition in (2) was arranged
so that if \(\{e\}_s^A(x)=y\) then \(\{e\}_s^\sigma(x)=y\) where
\(\sigma=A\restriction u(A;e,x,s)\))
\item \(\{e\}^\sigma(x)=y\) if \((\exists s)[\{e\}_s^\sigma(x)=y]\)
\end{enumerate}
\end{definition}

Note that this definition guarantees that
\begin{equation}
\{e\}_s^A(x)=y\Longrightarrow x,y,e<s;\quad u(A;e,x,s)\le s\label{eq3.1.1}
\end{equation}
and
\begin{align}
\{e\}_s^A(x)=y\Longrightarrow&(\forall t\ge s)[\{e\}_t^A(x)=y\\
&\;\&\;u(A;e,x,t)=u(A;e,x,s)]\nonumber\label{eq3.1.2}
\end{align}

Note that if \(A\) is recursive, then \(u(A;e,x,s)\) is a recursive function
and its index may be found uniformly in a \(\Delta_0\)-index for \(A\).

\begin{theorem}[Master Enumeration Theorem]
\label{thm3.1.8}
\begin{enumerate}
\item \(\{\la e,\sigma,x,s\ra:\{e\}_s^\sigma(x)\downarrow\}\) is recursive
\item \(L:=\{\la e,\sigma,x\ra:\{e\}^\sigma(x)\downarrow\}\) r.e.
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\item Perform the Turing computation according to \(\widehat{P}_e\) on input
\(x\) with \(\sigma\) written on the oracle tape until an output occurs or the
first \(s\) steps have been completed
\item \(L\) is \(\Sigma_1\)
\end{enumerate}
\end{proof}

\begin{theorem}[Use Principle]
\label{thm3.1.9}
\begin{enumerate}
\item \(\{e\}^A(x)=y\Longrightarrow(\exists s)(\exists \sigma\subset A)
      [\{e\}_s^\sigma(x)=y]\)
\item \(\{e\}_s^\sigma(x)=y\Longrightarrow(\forall t\ge
      s)(\forall\tau\supseteq\sigma
      [\{e\}_t^\tau(x)=y])\)
\item \(\{e\}^\sigma(x)=y\Longrightarrow(\forall A\supset\sigma)[\{e\}^A(x)=y]\)
\end{enumerate}
\end{theorem}

It follows from \eqref{eq3.1.1} and the Use Principle that
\begin{equation}
[\{e\}_s^A(x)=y\;\&\;A\restriction u=B\restriction u]
\Longrightarrow\{e\}_s^B(x)=y\label{eq3.1.3}
\end{equation}
where \(u=u(A;e,x,s)\) because \eqref{eq3.1.1} asserts that only elements
\(z<u\) are used in computation

\begin{definition}[]
\begin{enumerate}
\item Let \(W_e^A=\dom\{e\}^A\) and similarly define \(W_{e,s}^A\),
\(W_e^\sigma\) and \(W_{e,s}^\sigma\)
\item Let \(\Phi_e^A(x)=\Phi_e(A;x)=\{e\}^A(x)\) and
\(\Phi_{e,s}(A;x)=\{e\}_s^A(x)\)
\item Let \(\{e\}(x)\) denote \(\{e\}^\emptyset(x)\)
\end{enumerate}
\end{definition}

\begin{definition}[]
\begin{enumerate}
\item \(B\) is \textbf{recursive in (Turing reducible to)} \(A\), written \(B\le_T A\),
if \(B=\{e\}^A\) for some \(e\).  (We identify sets with their
characteristic functions.)
\item \(B\) is \textbf{recursively enumerable} in \(A\) if \(B=W_e^A\) for some \(e\).
\item \(B\) is in \(\Sigma_1^A\)-form (abbreviated \(B\) is \(\Sigma_1^A\)) if
\(B=\{x: (\exists\vec{y})R^A(x,\vec{y})\}\) for some \(A\)-recursive
predicate \(R^A(x,\vec{y})\). (By the Quantifier Contraction Theorem
\ref{thm2.1.3}, this is equivalent to asserting that \(B=\{x:(\exists
      y)R^A(x,y)\}\) for some \(R^A\))
\end{enumerate}
\end{definition}

\begin{theorem}[Complementation Theorem]
\(B\le_T A\) iff \(B\) and \(\overbar{B}\) are r.e. in \(A\)
\end{theorem}

\begin{theorem}[]
The following are equivalent
\begin{enumerate}
\item \(B\) is r.e. in \(A\)
\item \(B=\emptyset\) or \(B\) is the range of some \(A\)-recursive total function
\item \(B\) is \(\Sigma_1^A\)
\end{enumerate}
\end{theorem}

\begin{proof}
\((1)\to(3)\). Let \(B=W_e^A\). Hence by the Use Principle \ref{thm3.1.9},
\begin{equation}
x\in B\Longleftrightarrow(\exists s)(\exists\sigma)[\sigma\subset A
\;\&\;x\in W_{e,s}^\sigma]\label{eq3.1.4}
\end{equation}
Now \(x\in W_{e,s}^\sigma\) is a recursive relation on \((e,\sigma,x,s)\), and
\(\sigma\subset A\) is an \(A\)-recursive relation of \(\sigma\) because
\(\sigma\subset A\) iff \((\forall y<\ln(\sigma))[\sigma(y)=A(y)]\).  Hence
\eqref{eq3.1.4} is of the form \((\exists s,\sigma)R(e,\sigma,x,s)\) where \(R\) is an
\(A\)-recursive relation
\end{proof}
\subsubsection{Exercises}
\label{sec:orgda8c072}
\begin{exercise}
\label{eq3.1.14}
Given an effective coding of the program \(\{\widehat{P}_e\}_{e\in\omega}\)
and prove that under this coding \(\widehat{\varphi}_e:=\{e\}^\emptyset\) is an
acceptable numbering of the partial recursive functions as defined in
Exercise \ref{eq1.5.9}. Thus from now on we shall often use the functions
\(\{e\}(x)\), \(e\in\omega\) in place of \(\varphi_e(x),e\in\omega\)
\end{exercise}

\begin{exercise}
\label{eq3.1.15}
\begin{enumerate}
\item Prove that \(\{\la e,\sigma,x,y,s\ra:\{e\}_s^\sigma(x)=y\}\) is recursive
\item Prove that \(\{\la e,\sigma,x,y\ra:\{e\}^\sigma(x)=y\}\) is r.e., and that this set
and the set \(L\) of Theorem \ref{thm3.1.8} are each 1-complete and hence
recursively isomorphic to \(K\)
\end{enumerate}
\end{exercise}
\section{Reference}
\label{sec:orgbb2aa81}
\bibliographystyle{alpha}
\bibliography{../references}
\end{document}
