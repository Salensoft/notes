% Created 2020-06-10 三 08:44
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\input{preamble.tex}
%\\tf{\([^\}]*\)} \*\1\*
\author{Robert I. Soare}
\date{\today}
\title{Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets}
\hypersetup{
 pdfauthor={Robert I. Soare},
 pdftitle={Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents \clearpage\section{Recursive Functions}
\label{sec:org68f9ab1}
\subsection{Formal Definitions of Computable Functions}
\label{sec:orgf963527}
\subsubsection{Primitive Recursive Functions}
\label{sec:org8921510}
\begin{definition}[]
The class of primitive recursive functions is the smallest class \(\calc\) of
functions closed under the following schema
\begin{enumerate}
\item the \textbf{successor function}, \(\lambda x[x+1]\in\calc\)
\item the \textbf{constant functions}, \(\lambda x_1\dots x_n[m]\in\calc\), \(0\le n,m\)
\item the \textbf{identity function}, \(\lambda x_1\dots x_n[x_i]\in\calc\), \(1\le
      i\le n\)
\item (Composition) If \(g_1,\dots,g_m,h\in\calc\), then
\begin{equation*}
f(x_1,\dots,x_n)=h(g_1(x_1,\dots,x_n),\dots,g_m(x_1,\dots,x_n))
\end{equation*}
is in \(\calc\) where \(g_1,\dots,g_m\) are functions of \(n\) variables and \(h\)
is a function of \(m\) variables
\item (Primitive Recursion) If \(g,h\in\calc\) and \(n\ge 1\) then \(f\in\calc\) where
\begin{gather*}
f(0,x_2,\dots,x_n)=g(x_2,\dots,x_n)\\
f(x_1+1,x_2,\dots,x_n)=h(x_1,f(x_1,\dots,x_n),x_2,\dots,x_n)\\
\end{gather*}
\end{enumerate}
\end{definition}


Hence a function is primitve recursive if there is a \textbf{derivation}, namely
a sequence \(f_1,\dots,f_k=f\) s.t. for each \(f_i,i\le k\) is either an initial
function or obtained from 4 or 5.

A predicate (relation) is \textbf{primitive recursive} if its characteristic
function is.
\subsubsection{Diagonalization and Partial Recursive Functions}
\label{sec:org78466ec}
Although the primitive recursive functions include all the usual functions
from elementary number theory they fail to include \textbf{all} computable
functions. Each derivation of a primitive recursive function is a finite
string of symbols from a fixed finite alphabet, and thus all derivations can
be effectively listed. Let \(f_n\) be the function corresponding to the \(n\)th
derivation in this listing. Then the function \(g(x)=f_x(x)+1\) cannot be
primitive recursive.

The same argument applies to any effective set of schemata which produces
only \textbf{total} functions. \emph{Thus to obtain all computable functions we are}
\emph{forced to consider computable \textbf{partial} functions.}

\index{ partial recursive} \index{ p.r.}
\begin{definition}[Kleene]
\label{def2.2}
The class of \textbf{partial recursive} (p.r.) functions is the least class
obtained by closing under schemata 1 through 5 for the primitive recursive
functions and the following schemata 6. A \textbf{total recursive} function
(abbreviated \textbf{recursive} function) is a partial recursive function which
is total.
\begin{enumerate}
\setcounter{enumi}{5}
\item (Unbounded Search) If \(\theta(x_1,\dots,x_n,y)\) is a partial
recursive function of \(n+1\) variables, and 
\begin{align*}
\psi(x_1,\dots,x_n)=\mu y[\theta&(x_1,\dots,x_n,y)\downarrow=0\\
&\wedge (\forall z\le y)[\theta(x_1,\dots,x_n,z)\downarrow]]
\end{align*}
\end{enumerate}
\end{definition}
\begin{definition}[]
A relation \(R\subseteq \omega^n,n\ge 1\) is \textbf{recursive} (\textbf{primitive
recursive}, has property \(P\)) if its characteristic function \(\chi_R\) is
recursive (primitive recursive) where \(\chi_R(x_1\dots,x_n)=1\) if and only if
\((x_1,\dots,x_n)\in R\).
\end{definition}
\subsubsection{Turing Computable Functions}
\label{sec:org88cc14d}
A \textbf{Turing machine} \(M\) includes a two-way infinite \textbf{tape} divided into
\textbf{cells}, a \textbf{reading head} which scans one cell of the tape at a time,
and a finite set of internal \textbf{states} \(Q=\{q_0,\dots,q_n\},n\ge 1\). Each
cell is either blank (B) or has written on it the symbol 1. In a single step
the machine may simultaneously
\begin{enumerate}
\item change from one state to another
\item change the scanned symbol \(s\) to another symbol \(s'\in S=\{1,B\}\)
\item move the reading head one cell to the right (R) or left (L)
\end{enumerate}


The operation of \(M\) is controlled by a partial map 
\(\delta:Q\times S\to Q\times S\times\{R,L\}\)

The map \(\delta\) viewed as a finite set of quintuples is called a \textbf{Turing
program}. The \textbf{input} integer \(x\) is represented by a string of \(x+1\)
consecutive 1's.
\subsubsection{Exercises}
\label{sec:org85b5dd5}
\begin{exercise}[Definition by cases]
\label{ex2.6}
If \(g_1(x),\dots,g_n(x)\) are primitive recursive functions and
\(R_1(x),\dots,R_n(x)\) are primitive recursive relations which are mutually
exclusive and exhaustive show that \(f\) is primitive where \(f(x)=g_1(x)\)
if \(R_1(x)\),\(\dots\),\(f(x)=g_n(x)\) if \(R_n(x)\)
\end{exercise}

\begin{proof}
\(f(x)=\sum_{i=1}^n\chi_{R_i}(x)\times g_i(x)\)
\end{proof}
\subsection{The Basic Results}
\label{sec:orgb599886}
\textbf{Church's Thesis} asserts that these functions coincide with the
intuitively computable functions. We shall accept Church's Thesis and from
now on shall use the terms \emph{``partial recursive''} \emph{``Turing computable''} and
\emph{``computable''} interchangeably

\begin{definition}[]
Let \(P_e\) be the Turing program with code number (Gödel number) \(e\) 
(also called \textbf{index} \(e\)) in this
listing and let \(\varphi_e^{(n)}\) be the partial fucntions of \(n\) variables
computed by \(P_e\), where \(\varphi_e\) abbreviates \(\varphi_e^{(1)}\)
\end{definition}

\begin{lemma}[Padding Lemma]
Each partial recursive function \(\varphi_x\) has \(\aleph_0\) indices, and
furthermore for each \(x\) we can effectively find an infinite set \(A_x\) of
indices for the same partial function
\end{lemma}


\begin{proof}
For any program \(P_x\) mentioning internal states \(\{q_0,\dots,q_n\}\) add
extraneous instructions \(q_{n+1}Bq_{n+1}BR,q_{n+2}Bq_{n+2},BR,\dots\) to get
new programs for the same functions
\end{proof}
\begin{theorem}[Normal Form Theorem (Kleene]
\label{thm3.3}
There exist a predicate \(T(e,x,y)\) (called the \textbf{Kleene T-predicate}) and a
function \(U(y)\) which are recursive (indeed primitive recursive) s.t.
\begin{equation*}
\varphi_e(x)=U(\mu y T(e,x,y))
\end{equation*}
\end{theorem}

\begin{proof}
Informallz, the predicate \(T(e,x,y)\) asserts that \(y\) is the code number
of some Turing computation according to program \(P_e\) with input \(x\). To
see whether \(T(e,x,y)\) holds we first effectively recover from \(e\) the
Program \(P_e\); then recover from \(y\) the computation
\(c_0,c_1,\dots,c_n\) if \(y\) codes such a computation. Now check whether
\(c_0,\dots,c_n\) is a computation according to \(P_e\) with \(x\) as the
input in \(c_0\). If so \(U(y)\) simply outputs the number of \(1\)'s in the
final configuration \(c_n\).
\end{proof}

It follows from the Normal Form Theorem that every Turing computable partial
function is partial recursive. To prove the converse one constructs Turing
machines corresponding to the schemata \((1)\to(6)\).

Note by Theorem \ref{thm3.3} it follows that every partial recursive function
can be obtained from two primitive recursive functions by \textbf{one} application
of the \(\mu\)-operator

\begin{theorem}[Enumeration Theorem]
\label{thm3.4}
There is a p.r. function of 2 variables \(\varphi_z^{(2)}(e,x)\) s.t.
\(\varphi_z^{(2)}(e,x)=\varphi_e(x)\). Indeed the Enumeration Theorem holds for
p.r. functions of \(n\) variables
\end{theorem}
\begin{proof}
Let \(\varphi_z^{(2)}(e,x)=U(\mu y T(e,x,y))\). For
\(\varphi_z^{(n)}(e,x_1,\dots,x_{n-1})\), by \(s\)-\(m\)-\(n\) theorem, 
\begin{equation*}
\varphi_z^{(n)}(e,\bar{x})=
\varphi_{s^2_{n-1}(z,e)}^{(n-1)}(\bar{x})
\end{equation*}
Thus we only need to make sure that \(s^2_{n-1}(z,e)\in A_e\), which can be
effectively found.
\end{proof}
\begin{theorem}[Parameter Theorem ($s$-$m$-$n$ Theorem)]
For every \(m,n\ge 1\) there exists a 1:1 recursive function \(s^m_n\) of \(m+1\)
variables s.t. for all \(x,y_1,y_2,\dots,y_m\)
\begin{equation*}
\varphi_{s^m_n(x,y_1,\dots,y_m)}^{(n)}=\lambda z_1,\dots,z_n
(\varphi_x^{(m+n)}(y_1,\dots,y_m,z_1,\dots,z_n))
\end{equation*}
\end{theorem}
\begin{proof}
\emph{(informal)}. For simplicity consider the case \(m=n=1\).
\(\varphi^{(1)}_{s^1_1(x,y)}=\lambda z(\varphi_x^{(2)}(y,z))\)
The program
\(P_{s_1^1(x,y)}\) on input \(z\) first obtains \(P_x\) and then applies \(P_x\) to
input \((y,z)\). Now \(s=s_1^1\) is a recursive function by Church's Thesis
since this is an effective procedure in \(x\) and \(y\). If \(s\) is not
already 1:1 it may be replaced by a 1:1 recursive function \(s'\) s.t.
\(\varphi_{s(x,y)}=\varphi_{s'(x,y)}\) by sing the padding lemma, and by
defining \(s'(x,y)\) in increasing order of \(\la x,y\ra\), where
\(\la x,y\ra\) is the image of \((x,y)\) under the pairing function
\end{proof}

\begin{remark}
Here is an interesting question in \href{https://cs.stackexchange.com/questions/80837/is-smn-theorem-the-same-concept-as-currying}{StackExchange}
\end{remark}

The \(s\)-\(m\)-\(n\) theorem asserts that \(y\) may be treated as a fixed parameter
in the program \(P_{s(x,y)}\) which operate on \(z\) and furthermore that the
index \(s(x,y)\) of this program is effective in \(x\) and \(y\). A simple
application of the \(s\)-\(m\)-\(n\) theorem is the existence of a recursive
function \(f(x)\) s.t. \(\varphi_{f(x)}=2\varphi_x\). Let
\(\psi(x,y)=2\varphi_x(y)\). By Church's Thesis
\(\psi(x,y)=\varphi_e^{(2)}(x,y)\) for some \(e\). Let \(f(x)=s^1_1(e,x)\)

We let \(\la x,y\ra\) denote the image of \((x,y)\) under the standard pairing
function \(\frac{1}{2}(x^2+2xy+y^2+3x+y)\) which is a bijective recursive
function from \(\omega^2\to\omega\). Let \(\pi_1\) and \(\pi_2\) denote the inverse
functions \(\pi_1(\la x,y\ra)=x\)

For a relation \(R\subseteq\omega^n\), \(n>1\), we say that \(R\) has some
property \(P\) iff the set \(\{\la x_1,\dots,x_n\ra:R(x_1,\dots,x_n)\}\) has
property \(P\)

\begin{definition}[]
We write \(\varphi_{e,s}(x)=y\) if \(x,y,e<s\) and \(y\) is the output
\(\varphi_e(x)\) in \(<s\) steps of the Turing machine \(P_e\). If such a \(s\)
exists we say \(\varphi_{e,s}(x)\) \textbf{converges}, which we write as
\(\varphi_{e,s}(x)\downarrow\), and \textbf{diverges} (\(\varphi_{e,s}(x)\uparrow\)).
Similarly, we write \(\varphi_e(x)\downarrow\) if \(\varphi_{e,s}(x)\downarrow\)
for some \(s\)
\end{definition}

\begin{theorem}[]
\label{thm1.3.9}
\begin{enumerate}
\item The set \(\{\la e,x,s\ra:\varphi_{e,s}(x)\downarrow\}\) is recursive
\item The set \(\{\la e,x,y,s\ra:\varphi_{e,s}(x)=y\}\) is recursive
\end{enumerate}
\end{theorem}
\begin{proof}
From Church's Thesis since they are all computable
\end{proof}
\subsection{Recursively Enumerable Sets and Unsolvable Problems}
\label{sec:orgd67e998}
\index{ recursively enumerable}
\index{ r.e.}
\begin{definition}[]
\begin{enumerate}
\item A set \(A\) is \textbf{recursively enumerable} (r.e.) if \(A\) is the domain of
some p.r. function
\item let the \(e\)th r.e. set be denoted by
\begin{equation*}
W_e=\dom(\varphi_e)=\{x:\varphi_e(x)\downarrow\}=\{x:(\exists y)T(e,x,y)\}
\end{equation*}
\item \(W_{e,s}=\dom(\varphi_{e,s})\)
\end{enumerate}
\end{definition}

Note that \(\varphi_e(x)=x\) iff \((\exists s)[\varphi_{e,s}=y]\) and 
\(x\in W_e\) iff \((\exists s)(x\in W_{e,s})\)

\begin{definition}[]
Let \(K=\{x:\varphi_x(x)\text{ converges }\}=\{x:x\in W_x\}\)
\end{definition}
\begin{proposition}[]
\(K\) is r.e.
\end{proposition}
\begin{proof}
\(K\) is the domain of the following p.r. function
\begin{equation*}
\psi(x)=
\begin{cases}
x&\text{if } \varphi_x(x)\text{ converges},\\
\text{undefined}&\text{otherwise}
\end{cases}
\end{equation*}
Now \(\psi\) is p.r. by Church's Thesis since \emph{\(\psi(x)\) can be computed by}
\emph{applying program \(P_x\) to input \(x\) and giving output \(x\) only if}
\emph{\(\varphi(x)\) converges}. Alternatively and more formally,
\(K=\dom(\theta)\) where \(\theta(x)=\varphi_z^{(2)}(x,x)\) for \(\varphi_z^{(2)}\)
the p.r. function defined in the Enumeration Theorem \ref{thm3.4}
\end{proof}
\begin{corollary}[]
\label{col1}
\(K\) is not recursive
\end{corollary}
\begin{proof}
If \(K\) had a recursive characteristic function \(\chi_K\) then the following
function would be recursive
\begin{equation*}
f(x)=
\begin{cases}
\varphi_x(x)+1&\text{if }x\in K\\
0&\text{if }x\not\in K
\end{cases}
\end{equation*}
However \(f\) cannot be recursive since \(f\neq\varphi_x\) for any \(x\)
\end{proof}
\begin{definition}[]
\(K_0=\{\la x,y\ra:x\in W_y\}\)
\end{definition}
\(K_0\) is p.r. \(K_0=\dom\theta_0\), where
\(\theta(\la x,y\ra)=\varphi^{(2)}_z(y,x)\)

\begin{corollary}[]
\label{cor4.6}
\(K_0\) is not recursive
\end{corollary}
\begin{proof}
\(x\in K\) iff \(\la x,x\ra\in K_0\)
\end{proof}

The \textbf{halting problem} is to decide for arbitrary \(x\) and \(y\) whether
\(\varphi_x(y)\downarrow\). Corollary \ref{cor4.6} asserts the unsolvability of the
halting problem.

\begin{definition}[]
\begin{enumerate}
\item \(A\) is a \textbf{many-one reducible} (\textbf{\(m\)-reducible}) to \(B\) (written
\(A\le_m B\)) if there is a recursive function \(f\) s.t. \(f(A)\subseteq B\) and
\(f(\bar{A})\subseteq\bar{B}\), i.e. \(x\in A\) iff \(f(x)\in B\)
\item \(A\) is \textbf{one-one reducible} (\textbf{1-reducible}) to \(B\) (\(A\le_1 B\)) if
\(A\le_m B\) by a 1:1 recursive function
\end{enumerate}
\end{definition}

The proof of corollary \ref{cor4.6} established that \(K\le_1 K_0\) via the
function \(f(x)=\la x,x\ra\)
\begin{definition}[]
\begin{enumerate}
\item \(A\equiv_m B\) if \(A\le_m B\) and \(B\le_m A\)
\item \(A\equiv_1 B\) if \(A\le_1 B\) and \(B\le_1 A\)
\item \(\deg_m(A)=\{B:A\equiv_m B\}\)
\item \(\deg_1(A)=\{B:A\equiv_1 B\}\)
\end{enumerate}
\end{definition}

The equivalence classes under \(\equiv_m\) and \(\equiv_1\) are called the
\textbf{m-degrees} and \textbf{1-degrees} respectively

\begin{proposition}[]
If \(A\le_m B\) and \(B\) is recursive then \(A\) is recursive
\end{proposition}

\begin{proof}
\(\chi_A(x)=\chi_B(f(x))\)
\end{proof}

\begin{theorem}[]
\label{thm4.10}
\(K\le_1\text{Tot}:=\{x:\varphi_x\text{ is a total function}\}\)
\end{theorem}
\begin{proof}
Define the function
\begin{equation*}
\psi(x,y)=
\begin{cases}
1&\text{if } x\in K\\
\text{undefined} &\text{otherwise}
\end{cases}
\end{equation*}
By \(s\)-\(m\)-\(n\) theorem, there is a 1:1 recursive function \(f\) s.t.
\(\varphi_{f(x)}(y)=\psi(x,y)\). Choose \(e\) s.t. \(\varphi_e(x,y)=\psi(x,y)\) 
since \(\psi\) is p.r. and
define \(f(x)=s_1^1(e,x)\). Note that
\begin{align*}
&x\in K\Longrightarrow \varphi_{f(x)}=\lambda y[1]\Longrightarrow\varphi_{f(x)}\text{ total}
\Longrightarrow f(x)\in\text{Tot}\\
&x\not\in K\Longrightarrow\varphi_{f(x)}=\lambda y[\text{undefined}]\Longrightarrow
\varphi_{f(x)}\text{ not total}\Longrightarrow f(x)\not\in\text{Tot}
\end{align*}
\end{proof}

\begin{definition}[]
A set \(A\subseteq\omega\) is an \textbf{index set} if for all \(x\) and \(y\)
\begin{equation*}
(x\in A\wedge\varphi_x=\varphi_y)\Longrightarrow y\in  A
\end{equation*}
\end{definition}

\begin{theorem}[]
If \(A\) is a nontrivial index set, i.e., \(A\neq \emptyset,\omega\), then either
\(K\le_1 A\) or \(K\le_1\overline{A}\)
\end{theorem}

\begin{proof}
Choose \(e_0\) s.t. \(\varphi_{e_0}(y)\) is undefined for all \(y\). If
\(e_0\in\overline{A}\), then \(K\le_1 A\) as follows. Since \(A\neq\emptyset\) we can
choose \(e_1\in A\). Now \(\varphi_{e_1}\neq\varphi_{e_0}\) because \(A\) is an
index set. By \(s\)-\(m\)-\(n\) theorem define a 1:1 recursive function \(f\)
s.t.
\begin{equation*}
\varphi_{f(x)}(y)=
\begin{cases}
\varphi_{e_1}(y)&x\in K\\
\text{undefined}&x\not\in K
\end{cases}
\end{equation*}
Now
\begin{align*}
&x\in K\Longrightarrow\varphi_{f(x)}=\varphi_{e_1}\Longrightarrow f(x)\in A\\
&x\not\in K\Longrightarrow\varphi_{f(x)}=\varphi_{e_0}\Longrightarrow
f(x)\in\overline{A}
\end{align*}
\end{proof}

It's possible that both \(K\le_1 A\) and \(K\le_1\overline{A}\) for an index set
\(A\), for example if \(A=\text{Tot}\)
\begin{corollary}[Rice's Theorem]
Let \(\calc\) be any class of partial recursive functions. Then
\(\{n:\varphi_n\in\calc\}\) is recursive iff \(\calc=\emptyset\) or \(\calc\) is
the set of all partial recursive functions
\end{corollary}
\begin{proof}
\(\calc\) is an index set and hence is trivial.
\end{proof}
\begin{definition}[]
\begin{align*}
&K_1=\{x:W_x\neq\emptyset\}\\
&\text{Fin}=\{x:W_x\text{ is finite}\}\\
&\text{Inf}=\omega-\text{Fin}=\{x:W_x\text{ is infinite}\}\\
&\text{Tot}=\{x:\varphi_x\text{ is total}\}=\{x:W_x=\omega\}\\
&\text{Con}=\{x:\varphi_x\text{ is total and constant}\}\\
&\text{Cof}=\{x:W_x\text{ is cofinite}\}\\
&\text{Rec}=\{x:W_x\text{ is recursive}\}\\
&\text{Ext}=\{x:\varphi_x\text{ is extendible to a total recursive function}\}\\
\end{align*}
\end{definition}
\begin{definition}[]
An r.e. set \(A\) is \textbf{1-complete} if \(W_e\le_1 A\) for every r.e. set \(W_e\)
\end{definition}

\(K_0\) is 1-complete because \(x\in W_e\) iff \(\la x,e\ra\in K_0\)

\begin{definition}[]
Let \(A\) \textbf{join} \(B\) written \(A\oplus B\) be
\begin{equation*}
\{2x:x\in A\}\cup\{2x+1:x\in B\}
\end{equation*}
\end{definition}
\subsubsection{Exercises}
\label{sec:orgfe7fed2}
\begin{exercise}
\label{4.17}
\begin{enumerate}
\item \(A\le_m A\oplus B\) and \(B\le_m A\oplus B\)
\item if \(A\le_m C\) and \(B\le_m C\) then \(A\oplus B\le_m C\)
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item 

\item Easy
\end{enumerate}
\end{proof}

\begin{exercise}
\label{ex4.18}
\(K\equiv_1 K_0\equiv_1 K_1\)
\end{exercise}
\begin{proof}
\(K\le_1 A\) for \(A=K_1,\text{con}\) or
\(\text{Inf}\).

\(K_0\le K\) for the same reason.

For \(K\le K_1\)
\begin{equation*}
\varphi_{f(x)}(y)=
\begin{cases}
x&x\in K\\
\text{undefined}&x\not\in K
\end{cases}
\end{equation*}

For \(K_0\le_1 K\), the same (find a \(x\) s.t. \(x\in W_x\))

Also note that \(K\) and \(K_1\) are 1-complete
\end{proof}

\begin{exercise}
\label{ex4.19}
Prove directly (without Rice's theorem) that \(K\le_1\text{Fin}\)
\end{exercise}
\begin{proof}
Let
\begin{equation*}
\varphi_{f(x)}(s)=
\begin{cases}
0&x\not\in K_s\\
\text{undefined}&x\in K_s
\end{cases}
\end{equation*}
where \(K_s=W_{e,s}\) for some \(e\) s.t. \(K=W_e\). If \(x\in K\), then
\(\dom(\varphi_{f(x)})\) is finite
\end{proof}
\begin{exercise}
For any \(x\) show that \(\overline{K}\le_1\{y:\varphi_x=\varphi_y\}\) and
\(\overline{K}\le_1\{y:W_x=W_y\}\)
\end{exercise}
\begin{proof}
Use the method of exercise \ref{ex4.19}. If \(x\not\in W_x\), then
\(\dom(\varphi_{f(x)})=\omega\).
\end{proof}
\begin{exercise}
\(\text{Ext}\neq\omega\)
\end{exercise}
\begin{proof}
Use \(K\). If \(\psi(x)\) can be extended to a recursive function, then \(K\) would
be recursive.
\end{proof}

\begin{exercise}
\begin{enumerate}
\item Disjoints sets \(A\) and \(B\) are \textbf{recursively inseparable} if there is no
recursive set \(C\) s.t. \(A\subseteq C\) and \(C\cap B=\emptyset\). Show that
there exists disjoint r.e. sets which are recursively inseparable.
\item Give an alternative proof that \(\text{Ext}\neq\omega\)
\item For \(A\) and \(B\) as in part 1, prove that \(K\equiv_1 A\) and \(K\equiv_1 B\)
\end{enumerate}
\end{exercise}
\begin{proof}
\begin{enumerate}
\item Consider \(A=\{x:\varphi_x(x)=0\}\) and \(B=\{x:\varphi_x(x)=1\}\). If there
is a such recursive set \(C\) and its characteristic function is
\(\varphi_y\), then
\begin{equation*}
\varphi_y(x)=
\begin{cases}
1&\varphi_x(x)=0\\
1&\dots\\
0&\dots\\
0&\varphi_x(x)=1\\
\end{cases}
\end{equation*}
hence \(\varphi_y(y)\) leads to a contradiction.
\item corollary from 1.
\item The method are the same as \ref{thm1}
\end{enumerate}
\end{proof}

\begin{exercise}
A set \(A\) is \textbf{cylinder} if \((\forall B)[B\le_m A\Longrightarrow B\le_1 A]\)
\begin{enumerate}
\item Show that any index set is a cylinder
\item Show that any set of the form \(A\times\omega\) is a cylinder
\item Show that \(A\) is a cylinder iff \(A\equiv_1 B\times\omega\) for some set \(B\)
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item If different \(x,y\in B\) and \(f(x)=f(y)\), we could just add redundent
computation and \(\varphi_{f(x)}=\varphi_{f(y)}\)
\item to make sure images are different by \(\omega\)
\item 
\end{enumerate}
\end{proof}

\begin{exercise}
Show that the partial recursive functions are not closed under \(\mu\), i.e.,
there is a p.r. function \(\psi\) s.t. \(\lambda x[\mu y[\psi(x,y)=0]]\) is not p.r.
\end{exercise}
\begin{proof}
\(\psi(x,y)=0\) if \(y=1\) or \(y=0\) and \(\varphi_x(x)\downarrow\).
\end{proof}
\begin{exercise}
If \(A\) is recursive and \(B,\overline{B}\) are each \(\neq\emptyset\), then
\(A\le_m B\)
\end{exercise}
\begin{proof}
choose elements \(b\in B\) and \(b'\in\overline{B}\). Then
\begin{equation*}
\psi_{f(x)}(s)=
\begin{cases}
b&x\in A\\
b'&x\not\in A\\
\end{cases}
\end{equation*}
\end{proof}
\begin{exercise}
Prove that \(\text{Inf}\equiv_1\text{Tot}\equiv_1\text{Con}\)
\end{exercise}
\begin{proof}
\(\text{Tot}\equiv_1\text{Con}\) is obvious. For \(\text{Inf}\le_1\text{Con}\),
define
\begin{equation*}
\psi(e,x)=
\begin{cases}
0&\text{if }(\exists y>x)[\varphi_e(y)\downarrow]\\
\uparrow&\text{otherwise}
\end{cases}
\end{equation*}
\end{proof}

\begin{exercise}
\(\text{Fin}\le_1\text{Cof}\)
\end{exercise}
\begin{proof}
\begin{equation*}
\varphi_{f(e)}(s)=
\begin{cases}
\uparrow&\text{if } W_{e,s+1}-W_{e,s}\neq\emptyset\\
0&\text{otherwise}
\end{cases}
\end{equation*}
\end{proof}

\subsection{Recursive Permutation and Myhill's Isomorphism Theorem}
\label{sec:org6e61149}
\begin{definition}[]
\begin{enumerate}
\item A \textbf{recursive permutation} is a 1:1, recursive function from \(\omega\) to \(\omega\)
\item A property of set is \textbf{recursively invariant} if it's invariant under all
recursive permutation
\end{enumerate}
\end{definition}
Examples:
\begin{enumerate}
\item \(A\) is r.e. (\(A\le_1\im(A)\))
\item \(A\) has cardinality n
\item \(A\) is recursive
\end{enumerate}


Properties that not recursively invariant:
\begin{enumerate}
\item \(2\in A\)
\item \(A\) contains the even integers
\item \(A\) is an index set
\end{enumerate}


\begin{definition}[]
A is \textbf{recursively isomorphic} to \(B\) (written \(A\equiv B\)) if there is a
recursive permutation \(p\) s.t. \(p(A)=B\)
\end{definition}

\begin{definition}[]
The equivalence classes under \(\equiv\) are called \textbf{recursive isomorphism types}
\end{definition}

\begin{theorem}[Myhill Isomorphism Theorem]
\label{thm5.4}
\(A\equiv B\Longleftrightarrow A\equiv_1 B\)
\end{theorem}
\begin{proof}
(\(\Longrightarrow\)) trivial.

(\(\Longleftarrow\)) Let \(A\le_1 B\) via \(f\) and \(B\le_1 A\) via \(g\). We define a
recursive permutation \(h\) by stages so that \(h(A)=B\). We let
\(h=\bigcup_sh_s\), where \(h_0=\emptyset\) and \(h_s\) is that portion of \(h\)
defined by the end of stage \(s\). Assume \(h_s\) is given so that in particular
we can effectively check for membership in \(\dom{h_s}\) and \(\ran(h_s)\) which
we both assume finite

\emph{Stage} \(s+1=2x+1\). Assume that \(h_s\) is \(1:1\), \(\dom{h_s}\) is finite and \(y\in
   A\) iff \(h_s(y)\in B\) for all \(y\in\dom{h_s}\).If \(h_s(x)\) is defined, do
nothing. Otherwise enumerate the set
\(\{f(x),f(h_s^{-1}f(x)),\dots,f(h_s^{-1}f)^n(x),\dots\}\) until the fist
element \(y\) not yet in \(\ran(h_s)\). Define \(h_{s+1}(x)=y\). \(y\) must exist
since \(f\) and \(h_s\) are \(1:1\) and \(x\not\in\dom{h_s}\)

\emph{Stage} \(s+1=2x+2\). Define \(h^{-1}(x)\) similarly with \(f,h_s,\dom\) and
\(\ran\) replaced by \(g,h_s^{-1},\ran,\dom\) respectively
\end{proof}

\begin{definition}[]
A function \(f\) \textbf{dominates} a function \(g\) if \(f(x)\ge g(x)\) for almost every
(all but finitely many) \(x\in\omega\)
\end{definition}

\begin{exercise}[$\times$]
Prove that the primitive recursive permutations do not form a group under composition
\end{exercise}
\begin{proof}
Define \(g(x)=\mu yT(e,x,y)\). \(g\) dominates all primitive recursive functions
since \(y\ge U(y)\) for all \(y\). Suppose \(f\) is a primitive recursive
permutation and \(f(g(x))=x\) if \(x\) is even. Note that given \(y\) we can
primitively recursively compute whether there is an \(x\) s.t. \(g(x)=y\)
\end{proof}

\begin{exercise}
Let \(\omega=\bigcup_nA_n=\bigcup_nB_n\) where the sequences
\(\{A_n\}_{n\in\omega}\) and \(\{B_n\_{n\in\omega}\}\) are each pairwise disjoint.
Let \(f\) and \(g\) be 1:1 recursive functions s.t. \(f(A_n)\subseteq B_n\) and
\(g(B_n)\subseteq A_n\) for all \(n\). Show that the construction of Theorem
\ref{thm5.4} produces a recursive permutation \(h\) s.t. \(h(A_n)=B_n\) for all \(n\)
\end{exercise}
\section{Fundamentals of Recursively Enumerable Sets and the Recursion Theorem}
\label{sec:org950e418}
\subsection{Equivalent Definitions of Recursively Enumerable Sets}
\label{sec:org3f94a40}
\begin{definition}[]
\begin{enumerate}
\item A set \(A\) is a \textbf{projection} of some relation
\(R\subseteq\omega\times\omega\) if \(A=\{x:(\exists y)R(x,y)\}\)
\item A set \(A\) is in \textbf{\(\Sigma_1\)-form} (abbreviated ``A is \(\Sigma_1\)'') if
\(A\) is the projection of some recursive relation \(R\subseteq\omega\times\omega\).
\end{enumerate}
\end{definition}

\begin{theorem}[Normal Form Theorem for r.e. sets]
\label{thm2.1.2}
A set \(A\) is r.e. iff \(A\) is \(\Sigma_1\)
\end{theorem}

\begin{proof}
If \(A\) is r.e., then \(A=W_e\) for some \(e\). Hence
\begin{equation*}
x\in W_e\Leftrightarrow(\exists s)[x\in W_{e,s}]\Leftrightarrow
(\exists s)T(e,x,s)
\end{equation*}
and \(T(e,x,s)\) is primitive recursive

Let \(A=\{x:(\exists y)R(x,y)\}\), where \(R\) is recursive. Then
\(A=\dom\psi\), where \(\psi(x)=(\mu y)R(x,y)\)
\end{proof}

\begin{theorem}[Quantifier Contraction Theorem]
\label{thm2.1.3}
If there is a recursive relation
\begin{equation*}
R\subseteq\omega^{n+1}
\end{equation*}
and
\begin{equation*}
A=\{x:(\exists y_1)\dots(\exists y_n)R(x,y_1,\dots,y_n)\}
\end{equation*}
then \(A\) is \(\Sigma_1\)
\end{theorem}

\begin{proof}
Define the recursive relation \(S\subseteq \omega^2\) by
\begin{equation*}
S(x,z)\Leftrightarrow R(x,(z)_1,\dots,(z)_n)
\end{equation*}
where \(z=p_1^{(z)_1}\dots p_k^{(z)_k}\)
\end{proof}

\begin{corollary}[]
\label{cor2.1.4}
The projection of an r.e. relation is r.e.
\end{corollary}

\begin{definition}[]
The \textbf{graph} of a (partial) function \(\psi\) is the relation
\begin{equation*}
(x,y)\in\graph\psi\Leftrightarrow\psi(x)=y
\end{equation*}
\end{definition}

Using Theorem \ref{thm1.3.9} the following sets and relations are r.e.:
\begin{enumerate}
\item \(K=\{e:e\in W_e\}=\{e:(\exists s,y)[\varphi_{e,s}(e)=y]\}\)
\item \(K_0=\{\la x,e\ra:x\in W_e\}=\{\la x,e\ra:(\exists s,y)[\varphi_{e,s}(x)=y]\}\)
\item \(K_1=\{e:W_e\neq0\}=\{e:(\exists s,x)[x\in W_{e,s}]\}\)
\item \(\im\varphi_e=\{y:(\exists s,x)[\varphi_{e,s}(x)=y]\}\)
\item \(\graph\varphi_e=\{(x,y):(\exists s)[\varphi_{e,s}(x)=y]\}\)
\end{enumerate}


\begin{theorem}[Uniformization Theorem]
\label{thm2.1.6}
If \(R\subseteq\omega^2\) is an r.e. relation, then there is a p.r. function
\(\psi\) (called a \textbf{selector function} for \(R\)) s.t.
\begin{equation*}
\psi(x)\downarrow\Leftrightarrow(\exists y)R(x,y)
\end{equation*}
and in this case \((x,\psi(x))\in R\)
\end{theorem}

\begin{proof}
Since\(R\) is r.e. and hence \(\Sigma_1\), there is a recursive relation
\(S\) s.t. \(R(x,y)\) holds iff \((\exists z)S(x,y,z)\). Define the p.r.
function
\begin{equation*}
\theta(x)=(\mu u)S(x,(u)_1,(u)_2)
\end{equation*}
and set \(\psi(x)=(\theta(x))_1\)
\end{proof}

\begin{theorem}[Graph Theorem]
\label{thm2.1.7}
A partial function \(\psi\) is partial recursive iff its graph is r.e.
\end{theorem}

\begin{proof}
If the graph of \(\psi\) is r.e., then \(\psi\) is its own selector function.

If \(\psi\) is p.r., there is \(e\) s.t. \(\varphi_e=\psi\)
\end{proof}

\begin{theorem}[Listing Theorem]
A set \(A\) is r.e. iff \(A=\emptyset\) or \(A\) is the range of a total
recursive function.. Furthermore, \(f\) can be found uniformly in an index
for \(A\) as explained in Exercise \ref{ex2.1.25}
\end{theorem}

\begin{proof}
Let \(A=W_e\neq\emptyset\). Find the least integer \(\la a,t\ra\) s.t
\(a\in W_{e,t}\). Define the recursive function \(f\) by
\begin{equation*}
f(\la s,t\ra)=
\begin{cases}
x&x\in W_{e,s+1}-W_{e,s}\\
a&\text{otherwise}
\end{cases}
\end{equation*}
Clearly \(A=\im f\).

If \(A\) is the range of a total recursive function, \(A\) is \(\Sigma_1\)
\end{proof}

\begin{theorem}[Union Theorem]
\label{thm2.1.9}
The r.e. sets are closed under union and intersection uniformly effectively,
namely there are recursive functions \(f\) and \(g\) s.t.
\(W_{f(x,y)}=W_x\cup W_y\), and \(W_{g(x,y)}=X_x\cap W_y\)
\end{theorem}

\begin{proof}
Using the \(s\)-\(m\)-\(n\) Theorem define \(f(x,y)\) by enumerating
\(z\in W_{f(x,y)}\) if \((\exists s)[z\in W_{x,s}\cup W_{y,s}]\)
\end{proof}

\begin{corollary}[Reduction Principle for r.e. sets]
Given any two r.e. sets \(A\) and \(B\), there exist r.e. sets
\(A_1\subseteq A\) and \(B_1\subseteq B\) s.t. \(A_1\cap B_1=\emptyset\) and
\(A_1\cup B_1=A\cup B\)
\end{corollary}

\begin{proof}
Define the relation \(R:=A\times\{0\}\cup B\times{1}\) which is r.e. by
Theorem \ref{thm2.1.9}. By the Uniformization Theorem \ref{thm2.1.6}, let \(\psi\) be
the p.r. selector function for \(R\). Let \(A_1=x:\psi(x)=0\) and
\(B_1=x:\psi(x)=1\) 
\end{proof}

\begin{definition}[]
A set \(A\) is in \textbf{\(\Delta_1\)-form} (abbreviated ``\(A\) is \(\Delta_1\)'')
if both \(A\) and \(\bar{A}\) is \(\Sigma_1\).
\end{definition}

\begin{theorem}[Complementation Theorem]
\label{thm2.1.12}
A set \(A\) is recursive iff both \(A\) and \(\bar{A}\) are r.e. (i.e., iff \(A\in\Delta_1\))
\end{theorem}

\begin{proof}
Let \(A=W_e,\bar{A}=W_i\). Define the recursive function
\begin{equation*}
f(x)=(\mu s)[x\in W_{e,s}\vee x\in W_{i,s}]
\end{equation*}
Then \(x\in A\) iff \(x\in W_{e,f(x)}\), so \(A\) is recursive
\end{proof}

\begin{corollary}[]
\(\bar{K}\) is not r.e.
\end{corollary}

\begin{definition}[]
\begin{enumerate}
\item A \textbf{lattice} \(\call=(L;\le,\vee,\wedge)\) is a partially ordered set
(poset) in which any two elements have a least upper bound and greatest
lower bound. If \(a\) and \(b\) are elements of a lattice \(\call\),
\(a\vee b\) denote the least upper bound (lub) of \(a\) and \(b\),
\(a\wedge b\) the greatest lower bound (glb). If \(\call\) contains a
least element and greatest element these are called the \textbf{zero} element and
\textbf{unit} element 1. In such a lattice \(a\) is the \textbf{complement} of \(b\) if
\(a\vee b=1\)
\item A lattice is \textbf{distributive} if all its elements satisfy the distributive
laws
\((a\vee b)\wedge c=(a\wedge c)\vee(b\wedge c)\) and
\((a\wedge b)\vee c=(a\vee c)\wedge(b\vee c)\)
\item A lattice is \textbf{complemented} if every element has a complement
\item A poset closed under suprema but not necessarily under infima is an
\textbf{upper semi-lattice}
\item \(\calm=(\la M;\le,\vee,\wedge)\) is a \textbf{sublattice} of \(\call\) if
\(M\subseteq L\) and \(M\) is closed under the operations \(\vee\) and
\(\wedge\) in \(\call\)
\item A nonempty subset \(I\subseteq L\) forms an \textbf{ideal}
\(\cali=(I,\le,\wedge,\vee)\) of \(\call\) if \(I\) satisfies the
conditions
\begin{enumerate}
\item \([a\in L\;\&\;a\le b\in I]\Longrightarrow a\in I\)
\item \([a\in I\;\&\;b\in I]\Longrightarrow a\vee b\in I\)
\end{enumerate}
\item A subset \(D\subseteq L\) forms a \textbf{filter} \(\cald=(D;\le,\wedge,\vee)\)
of \(\call\) if it satisfies the dual conditions
\begin{enumerate}
\item \([a\in L\;\&\; a\ge b\in D]\Longrightarrow a\in D\)
\item \([a\in D\;\&\; b\in D]\Longrightarrow a\wedge b\in D\)
\end{enumerate}
\item Let \(\call\) be an upper semi-lattice. The definitions of ideal and
filter are the same except that we require (2) only when \(a\wedge b\)
exists. Furthermore, we say \(\cald\) is a \textbf{strong filter} in \(\call\) if
\(\cald\) satisfies (1) and also:
\begin{enumerate}
\item \([a\in\cald\;\&\;b\in\cald]\Leftrightarrow(\exists c\in\cald)
         [c\le a\;\&\;c\le b]\)
\end{enumerate}
\end{enumerate}
\end{definition}

The collection of all subsets of \(\omega\) forms a Boolean algebra,
\(\caln=(2^\omega;\subseteq,\cup,\cap)\) with \(\emptyset\) as least element
and \(\omega\) as the greatest element. The finite sets form an ideal \(\calf\)
of \(\caln\) and the cofinite sets form a filter \(\calc\) in \(\caln\)


\begin{definition}[]
\begin{enumerate}
\item By Theorem \ref{thm2.1.9} the r.e. sets form a distributive lattice
\(\cale\) under inclusion with greatest element \(\omega\) and least element \(\emptyset\)
\item By Theorem \ref{thm2.1.12} an r.e. set \(A\in\cale\) is recursive iff
\(\bar{A}\in\cale\). Hence the recursive sets form a Boolean algebra \(\calr\subseteq\cale\).
\end{enumerate}
\end{definition}
\subsubsection{exercise}
\label{sec:org624753f}

\begin{exercise}
\label{2.1.16}
\begin{enumerate}
\item Prove that \(A\le_m B\) and \(B\) r.e. imply \(A\) r.e.
\item Show that \(\Fin\) and \(\Tot\) are not r.e.
\item Show that \(\Cof\) is not r.e.
\end{enumerate}
\end{exercise}

\begin{proof}
\begin{enumerate}
\item 
\end{enumerate}
\end{proof}
\end{document}
