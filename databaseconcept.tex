% Created 2018-05-21 一 14:30
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{pst-plot}
\usepackage{color}
\usepackage{listings}
\usepackage{amssymb}
\author{wu}
\date{\today}
\title{ WEEK2}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.3.50.2 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents

\section{Chap1}
\label{sec-1}
\subsection{Taught}
\label{sec-1-1}
1-8, 10, 11-16, 22-23
\subsection{DBMS(database management system)}
\label{sec-1-2}
\subsubsection{collection of interrelated data}
\label{sec-1-2-1}
\subsection{DBMS solution}
\label{sec-1-3}
\subsubsection{Commercial/freeware DBMS}
\label{sec-1-3-1}
\subsubsection{Application programs}
\label{sec-1-3-2}
\subsection{View of data}
\label{sec-1-4}
\subsubsection{Levels of Abstraction}
\label{sec-1-4-1}
\begin{enumerate}
\item physical level
\label{sec-1-4-1-1}
how the data are stored
\item logical level
\label{sec-1-4-1-2}
relations among the data
\item view level
\label{sec-1-4-1-3}
\end{enumerate}
\subsubsection{Instances(实例) and schemas(模式)}
\label{sec-1-4-2}
\begin{description}
\item[{instance}] the collection of information stored in the
database at a particular moment
\item[{schema}] the overal design of the database
\end{description}
\subsubsection{Data module}
\label{sec-1-4-3}
\begin{enumerate}
\item a collections of tools for describing
\label{sec-1-4-3-1}
\begin{enumerate}
\item Data
\item Data relationships
\item Data semantics
\item Data constraints
\end{enumerate}
\end{enumerate}
\subsection{Relational database}
\label{sec-1-5}
\subsubsection{Relational model}
\label{sec-1-5-1}
\begin{center}
\begin{tabular}{rrrr}
ID & name & Dept$_{\text{name}}$ & Salary\\
22 & 112 & 131 & 13131\\
\end{tabular}
\end{center}
\subsubsection{Data definition language(DDL)}
\label{sec-1-5-2}
create table instructor (
ID char(5),
name varchar(5)
)
\begin{description}
\item[{DDL compiler}] generates a set of table templates
stored in a data dictionary
\item[{Data dictionary}] contains metadata
\end{description}
\subsubsection{Data manipulation language(DML)}
\label{sec-1-5-3}
Also known as query language(查询语言)
Types of access are
\begin{description}
\item[{Procedural}] user specifyies what data is required
and how to get the data
\item[{Declarative(nonprocedural)}] require a user to specify
what data are needed without
specifying how to get those data
\item[{query}] a statement requesting the retrieval of information
\end{description}
\subsection{SQL}
\label{sec-1-6}
\subsubsection{Example}
\label{sec-1-6-1}
Find the name of the instructor with ID 5
select name
from instructor
where instructor.ID = '5'
\subsubsection{Database design}
\label{sec-1-6-2}
\section{Chap2}
\label{sec-2}
\subsection{Structure of relational databases}
\label{sec-2-1}
\begin{description}
\item[{domain}] the set of permitted values of each attribute
\item[{atomic}] a domain is atomic if elements of the
domain are considered to be indivisible units
\item[{null}] a null value is a special value that signifies that
the value is unknown or does not exist
\end{description}
\subsection{Database schema}
\label{sec-2-2}
\begin{description}
\item[{database schema}] logical design of the database
\item[{database instance}] snapshot of the data in the database
at a given instant in time
\item[{relation schema}] consists of a list of attributs and their
conrresponding domains
\begin{itemize}
\item A₁,..,Aₙ are attributes
\item R = (A₁,\ldots{},Aₙ) is a relation schema
e.g. instructor$_{\text{schema}}$ = (ID, name, dept$_{\text{name}}$)
\item r(R) denotes a relation r on the relation schema
e.g. instructor(instructor$_{\text{schema}}$)
\item fiven sets D₁,\ldots{},Dₙ, a relation r is a subset of
D₁×D₂\ldots{}×Dₙ
Thus a relation is a set of n-tuples (a₁,\ldots{},aₙ) where each
aᵢ∈Dᵢ
\item The current values (relation instance) of a relation are specified
by a table
\item An element t of r is a tuple, represented by a row in a table
\end{itemize}

\item[{relation instance}] corresponds to the programming language notion
of a value of a varia
\end{description}
\subsection{Keys}
\label{sec-2-3}
Let K ⊆ R
\begin{description}
\item[{superkey}] K is a superkey of R if values for K are suffient to
identify a unique tuple of each possible relation r(R)
\item \{ID\} and \{ID, name\} are both superkeys of instrctor
\item[{candidate key}] s superkey K is minimal
\item \{ID\} is minimal
\item[{primary key}] one of the candidate key is chosen primary key
\item[{foreign key}] A relatoin schema may have an attribute that
corresponds to the primary key of another relation.
The attribute is called a foreign key
\end{description}
\subsection{Relational query language}
\label{sec-2-4}
\subsubsection{procedural, non-procedural, or declarative}
\label{sec-2-4-1}
\subsubsection{"Pure" language}
\label{sec-2-4-2}
\begin{itemize}
\item relational algebra
\item tuple relational calculus
\item domain relational calculus
\end{itemize}
\subsubsection{relational algebra}
\label{sec-2-4-3}
\begin{itemize}
\item procedural language
\item six basic operators
\begin{itemize}
\item selection: σ
\item projection: Π
\item union: ∪
\item natural join: ⋈ //SHEN MI
\item set different: -
\item cartesian product: ×
\end{itemize}
\end{itemize}
\section{{\bfseries\sffamily DONE} }
\label{sec-3}
  Ex 1.8, 1.9, 1.13, 1.15, 2.9, 2.13
Consider the bank database of Figure 2.15.
a. What are the appropriate primary keys?
b. Given your choice of primary keys, identify appropriate foreign keys.

branch(branch name, branch city, assets)
customer (customer name, customer street, customer city)
loan (loan number, branch name, amount)
borrower (customer name, loan number)
account (account number, branch name, balance)
depositor (customer name, account number)

Consider the bank database of Figure 2.15. Give an expression in the relational
algebra for each of the following queries:
a. Find all loan numbers with a loan value greater than \$10,000.
b. Find the names of all depositors who have an account with a value
greater than \$6,000.
c. Find the names of all depositors who have an account with a value
greater than \$6,000 at the “Uptown” branch
\section{Chap6}
\label{sec-4}
\subsection{Relational Algebra}
\label{sec-4-1}
\subsubsection{selection operation}
\label{sec-4-1-1}
\begin{itemize}
\item notation: σ$_{\text{ρ}}$(r)
\item[{selection predicate}] ρ
\item σ$_{\text{ρ}}$(r) = \{t | t ∈ r and p(t)\}
\item[{∧}] and
\item[{∨}] or
\end{itemize}
\subsubsection{project operation}
\label{sec-4-1-2}
\subsubsection{union operation}
\label{sec-4-1-3}
must have the same arity
the attribute domains must be compatible
\subsubsection{set difference operation}
\label{sec-4-1-4}
have same arity
attribute domains must be compatible
\subsubsection{Cartesian product operation}
\label{sec-4-1-5}
\begin{itemize}
\item r × s = \{t q | t ∈ r \textbf{and} q ∈ s\}
\item assume that r(R) and s(S) are disjoint
\item If not disjoint, then \textbf{renaming} must be used
\end{itemize}
\subsubsection{rename operation}
\label{sec-4-1-6}
ρₓ(E)
if E has arity n, then
ρₓ₍ₐ₁,\ldots{},ₐₙ₎(E)
\subsubsection{Additional operations}
\label{sec-4-1-7}
\begin{description}
\item[{set intersection}] r ∩ s = r - (r - s)
\item[{natural join}] (bowtie)
r ⋈ s
R = (A,B,C,D) S = (B, E, D) R ⋈ S = (A, B, C, D, E)
Cartesian product is renaming
projection of renaming of Cartesian product
natural join is associative and commutative
\item[{theta join}] r ⋈θ s
\item[{equijoin}] 
\item[{semijoin}] often used to compute natural joins in distributed databases
\item[{assignment}] ←
\item[{outer join}] \begin{itemize}
\item extension of join operation avoids loss of information
\item use \textbf{null} values:
\textbf{null} signifies the value is unknown or doesn't exist
instructor
\begin{center}
\begin{tabular}{rll}
ID & name & dept$_{\text{name}}$\\
1 & A & Comp\\
2 & B & Finance\\
3 & C & Miao\\
\end{tabular}
\end{center}
teaches
\begin{center}
\begin{tabular}{rl}
ID & course$_{\text{id}}$\\
1 & CS-101\\
2 & FIN-201\\
4 & BIO-201\\
\end{tabular}
\end{center}
left outer$_{\text{join}}$:
\begin{center}
\begin{tabular}{rlll}
ID & name & dept$_{\text{name}}$ & course$_{\text{id}}$\\
1 & A & Comp & CS-101\\
2 & B & Finance & FIN-201\\
3 & C & Miao & \textbf{null}\\
\end{tabular}
\end{center}
right outer join
\begin{center}
\begin{tabular}{rlll}
ID & name & dept$_{\text{name}}$ & course$_{\text{id}}$\\
1 & A & Comp & CS-101\\
2 & B & Finance & FIN-201\\
4 & \textbf{null} & \textbf{null} & BIO-201\\
\end{tabular}
\end{center}
full outer join
\begin{center}
\begin{tabular}{rlll}
ID & name & dept$_{\text{name}}$ & course$_{\text{id}}$\\
1 & A & Comp & CS-101\\
2 & B & Finance & FIN-201\\
3 & C & Miao & \textbf{null}\\
4 & \textbf{null} & \textbf{null} & BIO-201\\
\end{tabular}
\end{center}
\end{itemize}
\item[{null values}] three-ordered logic
\begin{center}
\begin{tabular}{llll}
or\and & null & true & false\\
null & null & null & null\\
true & null &  & \\
false & null &  & \\
\end{tabular}
\end{center}
\item[{division operator}] given relations r(R) and s(S) s.t. S
\end{description}
\subsubsection{Logical equivalence of RA plans}
\label{sec-4-1-8}
\begin{itemize}
\item σₐ₌₅(Πₐ(R)) = Πₐ(σₐ₌₅(R))
\end{itemize}
\subsection{extend relational algebra operations}
\label{sec-4-2}
\subsubsection{generalized projection}
\label{sec-4-2-1}
\begin{itemize}
\item extends the projection operation by allowing arithmetic functions to be
used in the projection list
\end{itemize}
\subsubsection{Aggregate functions and operations}
\label{sec-4-2-2}
\subsubsection{Multiset relational algebra}
\label{sec-4-2-3}
\section{{\bfseries\sffamily DONE} }
\label{sec-5}
  6.1 6.13
Write the following queries in relational algebra, using the university
schema.
a. Find the titles of courses in the Comp. Sci. department that have 3
credits.
b. Find the IDs of all students who were taught by an instructor named
Einstein; make sure there are no duplicates in the result.
c. Find the highest salary of any instructor.
d. Find all instructors earning the highest salary (there may be more
e. Find the enrollment of each section that was offered in Autumn 2009.
f. Find the maximum enrollment, across all sections, in Autumn 2009.
g. Find the sections that had the maximum enrollment in Autumn 2009.


employee (person name, street, city )
works (person name, company name, salary)
company (company name, city)
manages (person name, manager name)
Consider the relational database of Figure 6.22. Give a relational-algebra
expression for each of the following queries:
a. Find the company with the most employees.
b. Find the company with the smallest payroll.
c. Find those companies whose employees earn a higher salary, on average, than
the average salary at First Bank Corporation.
\section{Chap3}
\label{sec-6}
\subsection{SQL data definition}
\label{sec-6-1}
\subsubsection{Basic types}
\label{sec-6-1-1}
char(n): fixed length
varchar(n): variable-length
\subsubsection{Basic schema definition: table}
\label{sec-6-1-2}
\subsubsection{update to table}
\label{sec-6-1-3}
\begin{description}
\item[{insert}] 
\item[{delete}] 
\item[{drop table}] 
\item[{alter}] change the structure of the table
\begin{itemize}
\item \textbf{alter table r add A D}
where A is the name of the attribute to be added to relation
r and D is the domain of A
\item \textbf{alter table r drop A}
        A is the name of an attribute
\end{itemize}
\end{description}

\subsection{Foreign key and primary key}
\label{sec-6-2}
foreign keys are constraints
\subsection{Basic query structure}
\label{sec-6-3}
\begin{description}
\item[{select clause}] \begin{itemize}
\item to force the elimination of duplicates, insert the keyword \textbf{distinct}
\item \textbf{all} specifies that duplicates not to be removed
\item select * denotes all attributes.
\item An attribute can be a literal with no from clause
*select '437'*
results is a table with one column and a single row with value "437"
\item *select 'A' from instructor
result is a table with one column and N rows, each row with value "A"
\item Can also contain arithmetic expressions
\end{itemize}
\item[{where clause}] \begin{itemize}
\item Find the Cartesian product (select * from instructor, teaches)
generates every possible \textbf{instructor-teacher} pair
for common attribute, the attributes in the resulting table are renamed using
the relation name
\end{itemize}
\item[{join}] \begin{itemize}
\item the comma in from clause
\end{itemize}
\item[{natural join}] \begin{itemize}
\item select * from instructor natural join teaches
\end{itemize}
\item[{rename operation}] \begin{itemize}
\item \textbf{as}
\end{itemize}
\item[{string operation}] \begin{itemize}
\item \% matches any substring
\item underscore \_ matches any character
\item e.g. where name like '\%dar\%'
\item use \%: \%
\item concatenation ||
\item converting from upper to lower case
\item finding string length, extracting substring
\end{itemize}
\item[{ordering the display of tuples}] \begin{itemize}
\item select distinct name from instructor order by name
\item \textbf{desc} for descending order \textbf{asc} for ascending.
e.g. order by name desc
\item can sort on multiple attributes
e.g. order by dept$_{\text{name}}$, name
\end{itemize}
\item[{where clause predicates}] \begin{itemize}
\item \textbf{between}
       e.g. select name from instructor where salary between 90000 and 10000
\item tuple comparison
$(a_1,a_2)\le(b_1,b_2)$ iff $a_1\le b_1$ and $a_2\le b_2$
\end{itemize}
\item[{duplicate}] \begin{itemize}
\item Multiset
\end{itemize}
\item[{Set operation}] \begin{itemize}
\item union, intersect, except
each of the above operations automatically eliminates duplicates
\item to retain all duplicates, use union all, intersect all, except all
\end{itemize}
\item[{Null value}] \begin{itemize}
\item arithmetic expression involving null is null
\item is null can be used to check for null values
select name from instructor where salary is null
\end{itemize}
\item[{Aggregate functions}] \begin{itemize}
\item avg, min, max, sum, count
\item Except count, all aggregations apply to a single attribute
\item e.g. select avg(salary) from instructor where dept$_{\text{name}}$='Comp. Sci.';
\begin{center}
\begin{tabular}{r}
avg(salary)\\
750000\\
\end{tabular}
\end{center}
\item Find the number of tuples in the course relation
select count(*) from course;
\item[{grouping and aggregation}] \begin{itemize}
\item e.g. select product, sum from purchase group by product
\item 1.compute the from and where clauses
2.group by the attributes in the group
3.Compute the select clause
\end{itemize}
\item[{Having clause}] \begin{itemize}
\item predicates in the \textbf{having} clause are applied after the formation of groups
whereas predicates in the \textbf{where} clause are applied before groups
\end{itemize}
\item[{General form of grouping and aggregation}] \begin{itemize}
\item select S from R₁,\ldots{},Rₙ where C₁ group by a₁,\ldots{},aₙ having C₂
\end{itemize}
\end{itemize}
\item[{Nested subqueries}] \begin{itemize}
\item SQL provides a mechanism for the nesting of subqueries. A subquery is
a \textbf{select-from-where} expression that is nested within another query.
\end{itemize}
\item[{Set membership}] \begin{description}
\item[{in}] tests for set membership
\item[{not in}] 
\end{description}
\item[{set comparison-"some" clause}] > \textbf{some}
        < \textbf{some}
\item[{set comparison - "all" clasue}] > \textbf{all}
\textbf{select} name
\textbf{from} instructor
\textbf{where} salary > \textbf{all} (\textbf{select} salary
                    \textbf{from} instructor
                    \textbf{where} dept$_{\text{name}}$ = 'Biology');
\item[{Test for empty relations}] The \textbf{exists} construct returns the value \textbf{true} if te argument subquery
is nonempty
\item[{not exists}] 
\item[{unique}] \begin{itemize}
\item The \textbf{unique} construct tests whether a subquery has any duplicate tuples
in its result
\item The \textbf{unique} construct evaluates to "true" if a given subquery contains no duplicates
\end{itemize}
\item[{with}] \begin{itemize}
\item provides a way of defining a temporary relation whose definition is available only to
the query in which the \textbf{with} clause occurs
\item e.g
\textbf{with} max$_{\text{budget}}$(value) \textbf{as}
    (\textbf{select max} (budget)
    \textbf{from} department)
\textbf{select} department.name
\textbf{from} department, max$_{\text{budget}}$
\textbf{where} department.budget = max$_{\text{budget}}$.value;
\item is very useful for writing complex queries
\item with dept \_total (dept$_{\text{name}}$, value) as
   (select dept$_{\text{name}}$, sum(salary)
    from instructor
    group by dept$_{\text{name}}$),
dept$_{\text{total}}$$_{\text{avg}}$(value) as
   (select avg(value)
    from dept$_{\text{total}}$)
select dept$_{\text{name}}$
from dept$_{\text{total}}$, dept$_{\text{total}}$$_{\text{avg}}$
where dept$_{\text{total}}$.value > dept$_{\text{total}}$$_{\text{avg}}$.value;
\end{itemize}
\item[{insertion}] \begin{itemize}
\item \textbf{insert into \ldots{}} \textbf{values} \ldots{}.
\item \textbf{insert into} student
\textbf{select} ID, name, dept$_{\text{name}}$, 0
\textbf{from} instructor
\item \textbf{insert into} table1 \textbf{select} * \textbf{from} table1
\end{itemize}
\item[{update}] \begin{itemize}
\item \textbf{update} \ldots{} \textbf{set} \ldots{}. \textbf{where} \ldots{}
\item \textbf{update} \ldots{} \textbf{set} \ldots{} \textbf{case} \ldots{}
\textbf{when} \ldots{} \textbf{then} \ldots{}
\textbf{else} \ldots{}
\textbf{end}
\end{itemize}
\end{description}
\section{{\bfseries\sffamily DONE} }
\label{sec-7}
first 3.8 3.9
3.10 3.11 3.15
4.7 4.9 4.12
\section{Chap4}
\label{sec-8}
\subsection{Joined relations}
\label{sec-8-1}
\begin{description}
\item[{Join operation}] \begin{itemize}
\item takes two relations and return as a result another relation
\end{itemize}
\item[{outer join}] \begin{itemize}
\item an extension of the join operation that avoids loss of information
\item use \textbf{null} values
\item To distinguish normal joins from outer joins, normal joins are called
inter joins in SQL.
\end{itemize}
\item[{inner join}] \begin{itemize}
\item equivalent to \textbf{join}
\end{itemize}
\end{description}
\subsection{View}
\label{sec-8-2}
\begin{itemize}
\item In some cases, it's not desirable for all users to see the entire
logical model
\item A \textbf{view} provides a mechanism to hide certain data from the view of certain
users
\item \textbf{create view} v \textbf{as} <query expression>
\item once a view is defined, the view name can be used to refer to the
virtual relation that the view generates.
\item view is not a table
\item Most SQL implementations allow update only on simple views
\item The \textbf{select} contains only attribute names of the relation and doesn't
have any expressions, aggregates
\end{itemize}
\subsubsection{Materialized views}
\label{sec-8-2-1}
\begin{description}
\item[{Materializing a view}] create a physical table containing all the tuples in the result of the query
defining the view
\end{description}
\subsubsection{Transaction}
\label{sec-8-2-2}
\begin{itemize}
\item Atomic transaction
Either fully executed or rolled back as if never occured
\end{itemize}
\subsubsection{Integrated constraints}
\label{sec-8-2-3}
Integrity constraints guard against accidental damage to the database,
by ensuring that authorized changes to the database don't result
in a loss of data consistency
\subsubsection{Referential integrity}
\label{sec-8-2-4}
Ensures that a value that appears in one relation for a given set of attributes
also appears for a certain set of attributes in another relation
\subsection{Complex check clause}
\label{sec-8-3}
\textbf{check}
\subsection{DATATYPE}
\label{sec-8-4}
\subsubsection{Built-in data types in SQL}
\label{sec-8-4-1}
\begin{description}
\item[{date}] containing a (4 digit) year, month and data
\item[{time}] time of day, in hours, minutes
\textbf{time} '09:00:30'
\item[{timestamp}] date plus time of day
\item[{interval}] period of time
interval '1' day
\end{description}
\subsubsection{index creation}
\label{sec-8-4-2}
\begin{itemize}
\item \textbf{create} \textbf{index} studentID$_{\text{index}}$ \textbf{on} student(ID)
\item indices are data structures used to \textbf{speed up} access to records with
specified values for index attributes
\item e.g. select *
     from student
     where ID = '12345'
can be executed by using the index to find the required record
without looking at all records of student
\end{itemize}
\subsubsection{User-defined}
\label{sec-8-4-3}
\begin{itemize}
\item \textbf{create type} Dollars \textbf{as numeric} (12, 2) \textbf{final}
\item \textbf{create domain} person$_{\text{name}}$ \textbf{char} (20) \textbf{not null}
\end{itemize}
\subsubsection{large-object types}
\label{sec-8-4-4}
\begin{itemize}
\item large object are stored as large object
\begin{description}
\item[{blob}] binary large object
object is a large collection of uninterpreted binary data
\item[{clob}] character large object
\end{description}
\end{itemize}
\subsection{Authorization}
\label{sec-8-5}
\begin{description}
\item[{Forms of authorization on parts of the database}] \begin{itemize}
\item read
\item insert
\item update
\item delete
\end{itemize}
\item[{Forms of authorization to modify the database}] \begin{itemize}
\item index
\item resources
allow creation of new relations
\item alteration
\item drop
\end{itemize}
\end{description}
\subsubsection{Authorization specification in SQL}
\label{sec-8-5-1}
\begin{itemize}
\item \textbf{grant} <privilege list>
\textbf{on} <relation name or view name> \textbf{to} <user list>
\item <user list> is
\begin{itemize}
\item a user-id
\item \textbf{public} which allows all valid users the privilege granted
\item a role
\end{itemize}
\item granting on a privilege on a view doesn't imply granting any privileges on
the underlying relation
\end{itemize}
\subsubsection{privileges in SQL}
\label{sec-8-5-2}
\begin{description}
\item[{select}] \textbf{grant select on} instrutor \textbf{to} $U_1,U_2,U_3$
\item[{insert}] 
\end{description}
\subsubsection{revoking authorization in SQL}
\label{sec-8-5-3}
\begin{itemize}
\item the revoke statement is used to revoke authorization
\textbf{revoke} <privilege list>
\textbf{on} <relation name or view name> \textbf{from} <user list>
\end{itemize}
\subsubsection{role}
\label{sec-8-5-4}
\begin{itemize}
\item \textbf{create role} instructor
\item \textbf{grant} instructor \textbf{to} Amil
\item \textbf{grant select on} takes \textbf{to} instructor
\end{itemize}
\subsubsection{Authorization on views}
\label{sec-8-5-5}
\begin{itemize}
\item \textbf{grant select on} geo$_{\text{instructor}}$ \textbf{to} geo$_{\text{staff}}$
\end{itemize}
\subsubsection{other authorization fearture}
\label{sec-8-5-6}
\begin{itemize}
\item \textbf{grant reference} (dept$_{\text{name}}$) \textbf{on} department \textbf{to} Mariano
\end{itemize}
\section{Chap5}
\label{sec-9}
\subsection{Trigger}
\label{sec-9-1}
\begin{itemize}
\item a statement that the system executes automatically by the system as a side
effect of a modification to the database
\item to design, we must
specify the condition
specify the action
\end{itemize}
\subsubsection{example}
\label{sec-9-1-1}
time$_{\text{slot}}$$_{\text{id}}$ is not a primary key, so cannot create a foreign key constraint
Alternative we can use trigger
\textbf{create trigger} timeslot$_{\text{check1}}$ \textbf{after insert on} sectin
\textbf{referencing new row as} nrow
\textbf{for each row}
\textbf{when} (nrow.time$_{\text{slot}}$$_{\text{id}}$ \textbf{not in} (
    \textbf{select} time$_{\text{slot}}$$_{\text{id}}$
    \textbf{from} time$_{\text{slot}}$))
\textbf{begin}
    \textbf{rollback}
\textbf{end}
\subsubsection{triggering events and action in SQL}
\label{sec-9-1-2}
\begin{itemize}
\item triggering event can be \textbf{insert, delete} or \textbf{update}
\item triggering on update can be restricted to specific attributes
\textbf{after update of} takes \textbf{on} grade
\item values of attributes \textbf{before and after} an udpate can be referenced
\textbf{reference old row as}
\textbf{reference new row as}
\item triggers can be activated \textbf{before an event}
\end{itemize}
\subsubsection{statement level triggers}
\label{sec-9-1-3}
\begin{itemize}
\item instead of executing a seperate action for each affectedrow
a single action can be executed for all rows affected by a transaction
\begin{itemize}
\item use \textbf{for each statement}
\item use \textbf{referencing old table}
\end{itemize}
\end{itemize}
\subsection{Accessing SQL from a programming language}
\label{sec-9-2}
\begin{itemize}
\item To write an embedded SQL query, we use
\textbf{declare}
\item The \textbf{open} statment for our example is as follows:
\textbf{EXEC SQL open c};
This statement causes the database system to execute the query
and to save the results within a temporary relatoin
\item[{Dynamic SQL}] 
\item[{Embedded SQL}] \begin{itemize}
\item the SQL statements are identified at compile time using a preprocessor
\end{itemize}
\item Procedural extensions and stored procedures
\item Functions
\begin{description}
\item[{returns}] indicates the variable-type taht is returned
\item[{return}] specifies the values that are to be returned as result of invoking
the function
\end{description}
\end{itemize}
\section{{\bfseries\sffamily DONE} }
\label{sec-10}
  5.15 5.17 5.21
  employee (employee name, street, city)
works (employee name, company name, salary)

\section{Chap7: Entity-relationship model}
\label{sec-11}
\subsection{ER model}
\label{sec-11-1}
\begin{description}
\item[{model}] \begin{itemize}
\item A database can be modeled as :
a collection of entities
relation among entities
\item An \textbf{entity} is an object that is distinguishable from all other objects
An \textbf{entity} ahs a set of properties, and the values for some set of
properties may uniquely identify an entity
\item[{entity set}] \begin{itemize}
\item a set of entities of the same type that share the same properties,
or attributes
\end{itemize}
\end{itemize}
\item[{relation}] \begin{description}
\item[{A mathematical definition}] \begin{itemize}
\item Let A = \{1, 2, 3\}, B = \{a, b, c, d\}
\item We define a \textbf{relationship} of subset of $A\times B$
\end{itemize}
\item A \textbf{relationship} is an association among several entities.
\item[{relationship set}] 
\item[{degree of relationship set}] \begin{itemize}
\item binary relationship
involve two entity sets
most relationship sets in a database system are binary
\end{itemize}
\item[{Attributes}] 
\item[{mapping cardinality}] 
\item[{redundant attributes}] \begin{itemize}
\item suppose we have entity sets
instructor, with attributes including dept$_{\text{name}}$
department
\item and a relationship
inst$_{\text{dept}}$ relating instructor and department
\item Attribute dept$_{\text{name}}$ in entity instructor is redundant since there
is an explicit relationship inst$_{\text{dept}}$ which relates instructors
to department
\end{itemize}
\end{description}
\item[{E-R diagram}] \begin{description}
\item[{Roles}] \begin{itemize}
\item Entity sets of a relationship needn't to be distinct
Each occurence of an entity set plays a "role" in the relationship
\item Such as requisite course
\item The labels "course$_{\text{id}}$" and "prereq$_{\text{id}}$" are called roles
\end{itemize}
\item[{Cardinality constraint}] We express cardinality constraints by drawing either a directed
   line ->, signifying "one", or an undirected line (--), signifying
   "many"
$\to$
\item one-to-one relationship, one-to-many, many-to-one, many-to-many
\item[{total participation}] every entity in the entity set participates in at least one relationship
in the relationship set
\item[{Min and Max}] \begin{itemize}
\item A line may have an associtaed minimum and maximum cardinality, shown
in the form l..h, where l is the minimum and h the maximum cardinality
\item A maximum value of * indicates no limit
\end{itemize}
\item[{Cardinality constraints on ternary relationship}] 
\item[{Week entity set}] \begin{itemize}
\item An entity set that doesn't have a primary key is referred to as \textbf{weak}
         \textbf{entity set}
\item The existence of weak entity set depends on the existence of a
\textbf{identifying entity set}
\begin{itemize}
\item It must relate to the identifying entity set \textbf{via a total},
\textbf{one-to-many} relationship set from the identifying to the weak entity
set
\item \textbf{identifying relationship} depicted using a double diamond
\end{itemize}
\item The \textbf{discriminator} of a weak entity set is the set of attributes that
distinguishes among all the entities of a weak entity set
\item We underline the discriminator of a weak entity set with a dashed
lien
\end{itemize}
\item Binary vs non-binary relationship
\begin{itemize}
\item A ternary relationship parents, relating a child to his/her father and
mother
\item Any non-binary relationship can be represented using binary relationships
by creating an artificial entity set
\end{itemize}
\item[{Extended ER features}] \begin{description}
\item[{Specialization}] \begin{itemize}
\item top-down design process
\end{itemize}
\item[{Generalization}] \begin{itemize}
\item bottom-up design process
\end{itemize}
\end{description}
\item[{Aggregation}] \begin{itemize}
\item relation among relations
\end{itemize}
\end{description}
\end{description}
\subsection{UML}
\label{sec-11-2}
\begin{itemize}
\item unified modeling language
\end{itemize}
\section{{\bfseries\sffamily DONE} }
\label{sec-12}
7.1 7.2 7.20
Consider the E-R diagram in Figure 7.29, which models an online bookstore.
a. List the entity sets and their primary keys.
b. Suppose the bookstore adds Blu-ray discs and downloadable video
to its collection. The same item may be present in one or both formats,
with differing prices. Extend the E-R diagram to model this addition,
ignoring the effect on shopping baskets.
c. Now extend the E-R diagram, using generalization, to model the case
where a shopping basket may contain any combination of books,
Blu-ray discs, or downloadable video.
\section{Chap8: Relational database design}
\label{sec-13}
\subsection{First normal form}
\label{sec-13-1}
\begin{itemize}
\item domain is \textbf{atomic} if its elements are considered to be indivisible units
\item[{First normal form}] the domain of all attributes are atomic
\item Atomicity is actually a property of how the elements of the domain are used
\end{itemize}
\subsection{Functional dependencies}
\label{sec-13-2}
\begin{itemize}
\item constraints on the set of legal relations
\item require that the value for a certain set of attributes determines uniquely
the value for another set of attributes
\item Let $R$ be a relation scheme
$\alpha\subseteq R$ and $\beta\subseteq R$
\item the \textbf{functional dependency}
$\alpha\to\beta$
holds on $R$ if and only if for any legal relations r($R$), whenever any
two tuples $t_1$ and $t_2$ of r agree on the attributes $\alpha$, they also
agree on the attributes $\beta$ that is
$t_1[\alpha]=t_2[\alpha]\Rightarrow t_1[\beta]=t_2[\beta]$
\begin{center}
\begin{tabular}{rr}
A & B\\
1 & 4\\
1 & 5\\
3 & 7\\
\end{tabular}
\end{center}
here, $A\to B$ does \textbf{not} hold, but $B\to A$ hold
\item $K$ is a superkey for relation schema $R$ if and only if $K\to R$
$K$ is a candidate key for $R$ if and only
$K\to R$ and for no $a\subset K, a\to R$
\item \textbf{Functional dependencies} allow us to express constraints that cannot be expressed
using superkeys. E.g.
inst$_{\text{dept}}$($_{\text{ID}}$\_,name, salary, \uline{dept$_{\text{name}}$}, building, budget)
We would expect \emph{dept$_{\text{name}}$} $\to$ \emph{building} and \emph{ID} $\to$ \emph{building} hold
but \emph{dept$_{\text{name}}$} $\to$ \emph{salary} does not hold
\item[{usage}] \begin{itemize}
\item To test relations to see if they are legal under a given set of functional dependencies
\begin{itemize}
\item If a relation r is legal under a set F of functional dependencies, we say r
\textbf{satisfies} F
\end{itemize}
\item specify constraints on the set of legal relations
\begin{itemize}
\item We say \emph{F} \textbf{holds on} \emph{R} if all legal relations on \emph{R} satisfy the set of functional dependencies
\emph{F}
\end{itemize}
\end{itemize}
\item[{trivial}] it is satisfied by all instances of a relation
\item[{Closure of a set of functional dependencies}] \begin{itemize}
\item given a set $F$ of functional dependencies, there are certain other
functional dependencies that are logically implies by $F$
\begin{itemize}
\item e.g. If $A\to B$ and $B\to C$, then $A\to C$
\end{itemize}
\item The set of \textbf{all} functional dependencies logically implied by $F$ is the \textbf{closure} of $F$
       denoted by $F^+$
\end{itemize}
\end{itemize}
\subsection{Boyce-Codd normal form ::}
\label{sec-13-3}
\begin{itemize}
\item A relation schema $R$ is in BCNF w.r.t to a set $F$ of functional
dependencies if for all functional dependencies in $F^+$ of the form
$\alpha\to\beta$, at least one of the following holds:
$\alpha\to\beta$ is trivial
$\alpha$ is a superkey of $R$
\item decomposing a schema into BCNF
Supposing we have a schema \emph{R} and a non-trivial dependency $\alpha\to\beta$ causes
a violation of BCNF
We decompose \emph{R} into:
($\alpha\cup\beta$)
(R-($\beta-\alpha$))
\item BCNF and dependency predervation
\end{itemize}
\subsection{Third normal form}
\label{sec-13-4}
\begin{itemize}
\item for all $\alpha\to\beta$ in $F^+$, at least one of the following holds
$\alpha\to\beta$ is trivial
$\alpha$ is a superkey for R
Each attribute A in $\beta - \alpha$ is contained in a candidate key for R
\item[{Goals of normalization}] \begin{itemize}
\item Let \emph{R} be a relation scheme with a set \emph{F} of functional dependencies
\item Decide whether a relation \emph{R} is in "good" form
\item In the case that a relation scheme \emph{R} is not in "good" form,
decompose it into the set of relation scheme $\{R_1,\dots,R_n\}$ such that
\begin{itemize}
\item each relation scheme is in good form
\item the decomposition is a lossless-join decomposition
\item the decomposition should be denpendency preserving
\end{itemize}
\end{itemize}
\item minimal relaxiation of BCNF
\end{itemize}
\subsection{How good is BCNF}
\label{sec-13-5}
\begin{description}
\item[{consider a relation}] \begin{itemize}
\item inst$_{\text{info}}$(ID, child$_{\text{name}}$, phone)
\item \begin{center}
\begin{tabular}{rlr}
ID & child$_{\text{name}}$ & phone\\
99999 & David & 512-555-1234\\
99999 & David & 512-555-4321\\
99999 & William & 512-555-1234\\
99999 & William & 512-555-4321\\
\end{tabular}
\end{center}
\end{itemize}
\item[{problem}] \begin{itemize}
\item there are no non-trivial functional dependencies and therefore
the relation in BCNF
\item insertion anomalies -- if we add a phone 981-992-3443 to 99999,
we need to add two tupples
(99999, David, 981-992-3443)
(99999, William, 981-992-3443)
\end{itemize}
\item[{solution}] decompose \emph{inst$_{\text{info}}$} into two tables
\end{description}
\subsection{Closure of attributes sets}
\label{sec-13-6}
\begin{description}
\item[{Armstrong's axioms}] \begin{description}
\item[{reflexivity}] if $\beta\subseteq\alpha$, then $\alpha\to\beta$
\item[{augmentation}] if $\alpha\to\beta$, then $\gamma\alpha\to\gamma\beta$
\item[{transitivity}] if $\alpha\to\beta$ and $\beta\to\gamma$, then $\alpha\to\gamma$
\item these rules are
\begin{itemize}
\item \textbf{sound} (generate only functional dependencies that actually hold)
\item \textbf{complete} (generate all functional dependencies that hold)
\end{itemize}
\end{description}
\item[{Another rule}] \begin{description}
\item[{Union rule}] if $\alpha\to\beta$ and $\alpha\to\gamma$, then $\alpha\to\beta\gamma$
\item[{Decomposition rule}] if $\alpha\to\beta\gamma$, then $\alpha\to\beta,\alpha\to\gamma$
\item[{Pseudotransitivity rule}] If $\alpha\to\beta$ and $\gamma\beta\to\delta$, then $\alpha\gamma\to\delta$
\end{description}
\item Canonical Cover
\begin{itemize}
\item If we perform a update on the relation, the system must ensure the
update doesn't violate any functional dependencies. We need the reduce
the check time
\item[{extraneous attributes}] \begin{itemize}
\item Consider a set F of functional dependencies and the functional
dependency $\alpha\to\beta$ in F
\item A is extraneous in $\alpha$ if $A\in\alpha,F\to(F-\{\alpha\to\beta\})\cup\{(\alpha-A)\to\beta\}$
\item A is extraneous in $\beta$ if $A\in\beta, (F-\{\alpha\to\beta\})\cup\{\alpha\to(\beta-A)\}\to F$
\item For example, if we have $AB\to C, A\to C$, then B is extraneous in $AB\to C$
\item If $A\in\beta$, consider the set $F'=(F-\{\alpha\to\beta\})\cup\{\alpha\to(\beta-A)\}$
         check if $\alpha\to A$ can be inferred from $F'$. Compute $\alpha^+$ under $F'$, if $\alpha^+$
         includes A, then A is extraneous in $\beta$
\item If $A\in\alpha$, let $\gamma=\alpha-\{A\}$ and check if $\gamma\to\beta$ can be inferred from F.
To do so, compute $\gamma^+$ under F, if $\gamma^+$ includes all attributes in $\beta$
then A is extraneous
\item[{Canonical cover $F_c$'s properties}] \begin{itemize}
\item $F_c\Leftrightarrow F$
\item No functional dependency in $F_c$ contains an extraneous attribute
\item Each left side of a functional dependency in $F_c$ is unique.
$\forall \alpha_1\to\beta_1, \alpha_2\to\beta_2\in F_c,\alpha_1\neq\alpha_2$
\end{itemize}
\end{itemize}
\end{itemize}
\item[{Lossless decomposition}] \begin{itemize}
\item We say that decomposition is a lossless decomposition if there is no loss
of information by replacing $r(R)$ with two relation schemas $r_1(R_1),r_2(R_2)$
Or $\Pi_{R_1}(r)\bowtie\Pi_{R_2}(r)=r$
\item we can use functional dependencies to show when certain decompositions are lossless.
If at least one of the following functional dependencies is in $F^+$:
$R_1\cap R_2\to R_1$
$R_1\cap R_2\to R_2$
\end{itemize}
\item[{Dependency preservation}] \begin{itemize}
\item Let F be a set of functional dependencies on a schema R, and let $R_1, \dots,R_n$ be
a decomposition of R. The \textbf{restriction} of F to $R_i$ is the set $F_i$ of all functional
dependencies in $F^+$ that include \emph{only} attributes of $R_i$
\item Let $F'=F_1\cup\dots\cup F_n$, $F'^+=F^+$ is a \textbf{dependency-preserving decomposition}
\end{itemize}
\end{description}
\subsection{Algorithms for decomposition}
\label{sec-13-7}
\subsubsection{BCNF}
\label{sec-13-7-1}
\begin{description}
\item[{BCNF testing}] For every subset $\alpha$ of attributes in $R_i$, check that $\alpha^+$ either includes no
attribute of $R_i-\alpha$ or includes all attributes of $R_i$
\item[{BCNF decomposition}] \begin{itemize}
\item pseudocode
\lstset{language=Python,label= ,caption= ,numbers=none}
\begin{lstlisting}
result = {R}
done = False
F+=...
while not done:
    if Ri is not BCNF
        alphatobeta = nontrivial functional dependency hold on Ri and alphatoRi not in F+
        and alphacapbeta = None
        result = (result - Ri) cup (Ri - beta) cup (alpha, beta)
    else
        done = True
\end{lstlisting}
\end{itemize}
\end{description}
\subsubsection{3NF decomposition}
\label{sec-13-7-2}
\lstset{language=Python,label= ,caption= ,numbers=none}
\begin{lstlisting}
F_c = canonical cover for F
i = 0
for $\alpha\to\beta$ in F_c:
    i = i + 1
    R_i = $\alpha\beta$
if none of R_i contains a candidate keys:
    i = i + 1
    R_i = any candidate key of R
while R_j can be deleted(contains in another R):
    R_j = R_i
    i = i - 1
return (R_1, R_2, ..., R_i)
\end{lstlisting}
\subsection{Decomposition using multivalued dependencies}
\label{sec-13-8}
\begin{itemize}
\item Multivalued dependencies
\begin{itemize}
\item Multivalued dependencies, on the other hand, do not rule out the existence of
certain tuples. Instead, theyrequire that other tuples of a certain form be present in
the relation.
\item Let r(R) be a relation schema and let $\alpha\subseteq R$ and $\beta\subseteq R$. The \textbf{multivalued dependency}
$\alpha\twoheadrightarrow\beta$
holds on R if in any legal instance of relation r(R), for pairs of tuples $t_1, t_2$ in r
such that $t_1[\alpha]=t_2[\alpha]$, there exist tuples $t_3,t_4$ s.t.
$t_1[\alpha]=t_2[\alpha]=t_3[\alpha]=t_4[\alpha]$
$t_3[\beta]=t_1[\beta]$
$t_3[R-\beta]=t_2[R-\beta]$
\$t$_{\text{4[}\beta\text{]}}$=t$_{\text{2[}\beta\text{]}}$
$t_4[R-\beta]=t_1[R-\beta]$
\begin{center}
\begin{tabular}{llll}
 & $\alpha$ & $\beta$ & R-$\alpha$-$\beta$\\
t$_{\text{1}}$ & a$_{\text{1}}$\ldots{}a$_{\text{i}}$ & a$_{\text{i+1}}$\ldots{}a$_{\text{j}}$ & a$_{\text{j+1}}$\ldots{}a$_{\text{n}}$\\
t$_{\text{2}}$ & a$_{\text{1}}$\ldots{}a$_{\text{i}}$ & b$_{\text{i+1}}$\ldots{}b$_{\text{j}}$ & b$_{\text{j+1}}$\ldots{}b$_{\text{n}}$\\
t$_{\text{3}}$ & a$_{\text{1}}$\ldots{}a$_{\text{i}}$ & a$_{\text{i+1}}$\ldots{}a$_{\text{j}}$ & b$_{\text{j+1}}$\ldots{}b$_{\text{n}}$\\
t$_{\text{4}}$ & a$_{\text{1}}$\ldots{}a$_{\text{i}}$ & b$_{\text{i+1}}$\ldots{}b$_{\text{j}}$ & a$_{\text{j+1}}$\ldots{}a$_{\text{n}}$\\
\end{tabular}
\end{center}
\item If $\alpha\to\beta$, then $\alpha\twoheadrightarrow\beta$
       If $\alpha\twoheadrightarrow\beta$, then $\alpha\twoheadrightarrow R-\alpha-\beta$
\end{itemize}
\item Fourth normal form
\begin{itemize}
\item for all multivalued dependencies in $D^+$, at least one of the following holds
\begin{itemize}
\item $\alpha\twoheadrightarrow\beta$ is a trivial multivalued dependency
\item $\alpha$ is a superkey for R
\end{itemize}
\item Every 4NF schema is in BCNF
\item \textbf{restriction} of D to $R_i$ is the set $D_i$ consisting of:
\begin{itemize}
\item All functional dependencies in $D^+$ that include only attributes of $R_i$
\item All multivalued dependencies of the form:
$\alpha\twoheadrightarrow\beta\cap R_i$
where $\alpha\subseteq R_i$ and $\alpha\twoheadrightarrow\beta$ is in $D^+$
\end{itemize}
\item[{Decomposition}] \begin{itemize}
\item really same to BCNF
\end{itemize}
\end{itemize}
\end{itemize}
\section{Chap10}
\label{sec-14}
\subsection{Overview}
\label{sec-14-1}
cache
main memory
flash memory
magnetic disk
optical disk
magnetic tapes
\subsection{Magnetic disk and flash storage}
\label{sec-14-2}
\subsubsection{physical characteristics of disks}
\label{sec-14-2-1}
\begin{itemize}
\item a disk contains many \textbf{platter}
\item each disk \textbf{platter} has a flat, circular shape
\item the disk surface is logically divided into \textbf{tracks}, which are subdivided into
\textbf{sectors}. A \textbf{sector} is the smalles unit of information
\item ith tracks of all the platters together are called the ith \textbf{cylinder}
\item \textbf{disk controller}
\end{itemize}
\subsubsection{Performance measures of disks}
\label{sec-14-2-2}
\begin{description}
\item[{Access time}] \begin{itemize}
\item the time it takes \textbf{from} when a read or write request is issued \textbf{to} when
data transfer begins. Consist of:
\begin{description}
\item[{Seek time(寻道时间)}] \begin{itemize}
\item time it takes to reposition the arm over the correct track
\end{itemize}
\item[{Rotational latency}] \begin{itemize}
\item time it takes for the \textbf{sector} to be accessed to appear under the head
\end{itemize}
\end{description}
\end{itemize}
\item[{Data-transfer rate}] \begin{itemize}
\item the rate at which data can be retrived from or stored to the disk
\end{itemize}
\item[{Mean time to failure(MTTF)(平均故障间隔期)}] \begin{itemize}
\item the average time the disk is expected to run continuously without any
failure
\item 总磁盘越多，随机的磁盘发生故障成为常态
\end{itemize}
\end{description}
\subsubsection{optimization of disk-block access}
\label{sec-14-2-3}
\begin{description}
\item[{Block}] \begin{itemize}
\item a contiguous sequence of sectors from a single track
\item data is transfered between disk and main memory in blocks
\end{itemize}
\item[{Disk-arm-scheduling}] \begin{itemize}
\item algorithms order pending accesses to tracks so that disk arm movement
is minimized
\item elevator algorithm
\end{itemize}
\item[{File organization}] \begin{itemize}
\item optimize block access time by organizing the blocks to correspend to
how data will be accessed
\item e.g. store related information on the same nearby cylinders
\end{itemize}
\item[{Nonvolatile write buffers}] \begin{itemize}
\item speed up disk writes by writing blocks to a non-volatile RAM buffer
immediately
\item controller then writes to disk whenever the disk has no other requests
or request has been pending for some time
\end{itemize}
\item[{Log disk}] \begin{itemize}
\item a disk devoted to writing a sequential log of block updates
\item used like nonvolatile RAM
\end{itemize}
\end{description}
\subsubsection{flash storage}
\label{sec-14-2-4}
\begin{description}
\item[{NAND flash}] \begin{itemize}
\item requires page-at-a-time read
\item ssd (solid state disks) use multiple flash storage
\item erase is slow
\end{itemize}
\end{description}
\subsection{RAID(Redundant arrays of independent disks)}
\label{sec-14-3}
\begin{itemize}
\item high capacity and high speed by using multiple disks in parallel.
high reliability by storing data redundantly
\item[{redundancy}] \begin{itemize}
\item store extra information that can be used to rebuild information
lost in a disk failure
\item E.g. \textbf{Mirroring}
\end{itemize}
\item Mean time to failure
\end{itemize}
\subsubsection{improvement in performance via parallelism}
\label{sec-14-3-1}
\begin{itemize}
\item two main goals of parallelism in a disk system
\begin{itemize}
\item load balance multiple small accesses to increase throughput
\item parallelize large accesses to reduce response time
\end{itemize}
\item[{bit-level striping}] split the bits of each byte across multiple disks
\item[{block-level striping}] with n disks, block i goes to disk (i mod n) + 1
\end{itemize}
\subsubsection{Raid level}
\label{sec-14-3-2}
\subsection{File organization}
\label{sec-14-4}
\subsubsection{fixed-length records}
\label{sec-14-4-1}
\begin{itemize}
\item store record i starting from byte n * (i - 1), where n is the size of each record
\item deletion
\begin{itemize}
\item free list
store the address of the first deleted record in the file header
\end{itemize}
\end{itemize}
\subsubsection{varaible-length record}
\label{sec-14-4-2}
\begin{itemize}
\item arise in several ways
\begin{itemize}
\item storage of multiple record types in a file
\item record types that allow variable lengths for one or more fields such as strings
\item record types that allow repeating fields
\end{itemize}
\item variable length attributes represented by fixed szie, with actual data stored after
all fixed length attributes
\item null values represented by null-value bitmap
\item[{slotted page structure}] \begin{itemize}
\item contains
number of record entries
end of free space in the block
location and size of each record
\item records can be moved around within a page to keep them contiguous with no empty space
between them
\item pointers shouldn't point directly to record--instead they should point to the entry
for the record in header
\end{itemize}
\end{itemize}
\subsubsection{organization of records in files}
\label{sec-14-4-3}
\begin{itemize}
\item sequential file organization
\item multitable clustering file organization
\end{itemize}
\subsection{data dictionary storage}
\label{sec-14-5}
\begin{itemize}
\item data dictionary stores \textbf{metadata}
\item information about relations
\item user and accouting information
\item statistical and descriptive data
\item physical file organization
\end{itemize}
\section{{\bfseries\sffamily TODO} }
\label{sec-15}
10.8 10.14 10.17
\section{Chap 11}
\label{sec-16}
\subsection{Basic concepts}
\label{sec-16-1}
\begin{description}
\item[{index file}] \begin{itemize}
\item consist of records of the form
\begin{center}
\begin{tabular}{ll}
search-key & pointer\\
\end{tabular}
\end{center}
\item two kinds of indices
\begin{itemize}
\item ordered indices
\begin{itemize}
\item primary index
\begin{itemize}
\item the index whose search key specifies the sequential order of the file
\end{itemize}
\item secondary index
\begin{itemize}
\item the index whose search key specifies the sequential order of the file
\end{itemize}
\end{itemize}
\item hash indices
\end{itemize}
\item index evaluation metrics
\begin{itemize}
\item access types
\item access time
\item insertion time
\item deletion time
\item space overhead
\end{itemize}
\end{itemize}
\end{description}
\subsection{Ordered indices}
\label{sec-16-2}
\begin{itemize}
\item index entities are stored sorted on the search key value
\item[{primary index(clustering index)主索引}] \begin{itemize}
\item not primary key
\item the index whose search key specifies the sequential order of the file
\end{itemize}
\item[{secondary index(non-clustring index)}] \begin{itemize}
\item an index whose search key specifies an order different from
the sequential order of the file
\item e.g.
\end{itemize}
\item[{dense index}] \begin{itemize}
\item index record appears for every search-key value
\end{itemize}
\item[{sparse index files}] \begin{itemize}
\item contains index records for only some search-key
\item compared to dense indices
\begin{itemize}
\item less space and less maintenance
\item generally slower than dense index
\end{itemize}
\item good tradeoff
\begin{itemize}
\item sparse index with an index entry for every block in file, corresponding
to least search-key value in the block
\end{itemize}
\end{itemize}
\item[{multilevel index}] 
\end{itemize}
\subsection{B+-tree index files}
\label{sec-16-3}
\subsection{B+-tree file organization}
\label{sec-16-4}
\begin{itemize}
\item leaf nodes store records
\end{itemize}
\subsection{Bulk loading and bottom-up build}
\label{sec-16-5}
\begin{itemize}
\item problem
inserting entries one-at-a-time into a B+-tree requires >= 1 IO per entry
\item efficient alternative 1
sort entries first
\item efficient alternative 2: bottom-up B+-tree construction
starting with leaf level
\end{itemize}
\subsection{Multiple-key access}
\label{sec-16-6}
\begin{itemize}
\item 
\end{itemize}
\lstset{language=SQL,label= ,caption= ,numbers=none}
\begin{lstlisting}
select ID
from instructor
where dept_name = "Finance" and salary = 80000
\end{lstlisting}
\section{{\bfseries\sffamily DONE} }
\label{sec-17}
11.3a 11.4
\section{chap12}
\label{sec-18}
\subsection{Measure of query cost}
\label{sec-18-1}
\begin{description}
\item[{factors}] \begin{itemize}
\item disk accesses
\item CPU
\item number of seeks
\item number of blocks read
\item number of blocks written
\end{itemize}
\item $t_T$ time to transfer one block
$t_S$ time for one seek
\item use worst case estimates
\end{description}
\subsection{selectoin operation}
\label{sec-18-2}
\subsubsection{file scan}
\label{sec-18-2-1}
\begin{description}
\item[{A1 (linear search)}] \begin{itemize}
\item cost = $b_r$ block transfers + 1 seek
$b_r$ denotes number of blocks containing records from relation r
\end{itemize}
\end{description}
\subsubsection{index scan}
\label{sec-18-2-2}
\begin{description}
\item[{A2 (primary index, equality on key)}] \begin{itemize}
\item retrieve a single record taht satisfy the corresponding equality condition
\item cost = $(h_i+1)*(t_T+t_s)$
\end{itemize}
\item[{A3 (primary index, equality on nonkey)}] 
\item[{A4 (secondary index, equality on nonkey)}] \begin{itemize}
\item retrieve a single record if the search-key is a candidate key
\item cost = $(h_i+1)*(t_T+t_S)$
\item retrieve multiple records if search-key is not a candidate key
\end{itemize}
\end{description}
\subsubsection{selection involving comparisons}
\label{sec-18-2-3}
\begin{itemize}
\item can implement selections of the form $\sigma_{A\le V}(r)$ or $\sigma_{A\ge V}(r)$
\item[{A5 (primary index, comparison)}] \begin{itemize}
\item relation sorted on A
\end{itemize}
\item A6 (secondary index
\end{itemize}
\subsubsection{implementation of complex selections}
\label{sec-18-2-4}
\begin{itemize}
\item conjunction $\sigma_{\theta_1}\cap\dots\sigma_{\theta_n}(r)$
\item[{A7 (conjunctive selection using one index)}] \begin{itemize}
\item select a combination of $\theta_i$ and algorithms A1 through A7 that
results in the least cost for $\sigma_{\theta_i}(r)$
\end{itemize}
\item[{A8 (conjunctive sleelction using composite index)}] 
\item[{A9 (conjunctive selection by intersection of identifiers)}] 
\end{itemize}
\subsection{external sort-merge}
\label{sec-18-3}
\subsection{Join}
\label{sec-18-4}
\subsubsection{nested-loop join}
\label{sec-18-4-1}
\begin{itemize}
\item $r\bowtie_{\theta} s$
\item worst
$n_r\times b_s + b_r$
\end{itemize}
\subsubsection{block nested-loop join}
\label{sec-18-4-2}
\subsubsection{indexed nested-loop join}
\label{sec-18-4-3}
\begin{itemize}
\item for each tuple in the outer relation $r$, a lookup is performed on the index
for $s$, and the relevant tuples are retrieved.
\item in the worst case, $b_r$ I/O operations are needed to read relation $r$
      $b_r(t_T+t_S)+n_r\times c$
\end{itemize}
\subsubsection{merge join}
\label{sec-18-4-4}
\begin{itemize}
\item w
\begin{enumerate}
\item sort both relations on their join attribute
\item merge the sorted relations
\end{enumerate}
\end{itemize}
\subsubsection{hash join}
\label{sec-18-4-5}
\subsection{evaluation of expression}
\label{sec-18-5}
\subsubsection{materialization}
\label{sec-18-5-1}
\begin{itemize}
\item evaluate one operation at a time, starting at the lowest-level. Use intermediate
results materialized into temporary relations to evaluate next-level operations
\item[{double buffering}] \begin{itemize}
\item use two output buffers for each operation, when one is ful
\end{itemize}
\end{itemize}
\subsubsection{pipeline}
\label{sec-18-5-2}
\begin{itemize}
\item evaluate several operations simultaneously, passing the results of one operation
on to the next
\end{itemize}
\section{{\bfseries\sffamily TODO} }
\label{sec-19}
12.2 12.3b
\section{chap13}
\label{sec-20}
\subsection{overview}
\label{sec-20-1}
\begin{description}
\item[{evalutaion plan}] defines exactly what algorithm is used for each operation and
how the execution of the operations is coordinate.
\item[{cost-based query optimization}] \begin{itemize}
\item generate logically equivalent expressions using \textbf{equivalence rules}
\item annotate resultant expressions to get alternative query plans
\item choose the cheapest plan based on \textbf{estimated cost}
\end{itemize}
\end{description}
\subsection{transformation}
\label{sec-20-2}
\begin{description}
\item[{equivalent rules}] \begin{enumerate}
\item conjunctive selection operations
$\sigma_{\theta_1\cap\theta_2}(E)=\sigma_{\theta_1}(\sigma_{\theta_2}(E))$
\item commutative
$\sigma_{\theta_1}(\sigma_{\theta_2}(E))=\sigma_{\theta_2}(\sigma_{\theta_1}(E))$
\item only the last in a sequence of projection operations is needed
$\prod_{L_1}(\prod_{L_2}(\dots(\prod_{L_n}(E))\dots))=\prod_{L_1}(E)$
\item $\sigma_\theta(E_1\times E_2)=E_1\bowtie_\theta E_2$
        $\sigma_{\theta_1}(E_1\bowtie_{\theta_2} E_2)=E_1\bowtie_{\theta_1\wedge\theta_2} E_2$
\item theta-join operations are commutative
\item associative
\item the selection operation distributes over the theta-join operation under the following
two conditions
$\sigma_{\theta_0}(E_1\bowtie_\theta E_2)=(\sigma_{\theta_0}(E_1))\bowtie_\theta E_2$
$\sigma_{\theta_1\wedge\theta_2}(E_1\bowtie_\theta E_2)=(\sigma_{\theta_1}(E_1))\bowtie_\theta(\sigma_{\theta_2}(E_2))$
\item $\prod_{L_1\cup L_2}(E_1\bowtie_\theta E_2)=(\prod_{L_1}(E_1))\bowtie_\theta(\prod_{L_2}(E_2))$
\begin{itemize}
\item let $L_3$ are attributes of $E_1$ that are involved in join condition $\theta$
          $\prod_{L_1\cup L_2}(E_1\bowtie_\theta E_2)=\prod_{L_1\cup L_2}((\prod_{L_1\cup L_3(E_1)}))
          \bowtie_\theta(\prod_{L_2\cup L_4}(E_2))$
\end{itemize}
\item $\sigma_P(E_1-E_2)=\sigma_P(E_1)-\sigma_P(E_2)$
\end{enumerate}
\end{description}
% Emacs 25.3.50.2 (Org mode 8.2.10)
\end{document}